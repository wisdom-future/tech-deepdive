<script>
/**
 * @file frontend/page_exploration.js.html
 * @description Handles the Exploration page logic, including the multi-modal HUD, sub-tabs, and new exploration views.
 * @version 2.2 (Implemented Galaxy Map Drill-Down)
 */

const SpacetimeRenderer = {
  // Three.js æ ¸å¿ƒå¯¹è±¡
  scene: null,
  camera: null,
  renderer: null,
  controls: null,

  // UI åŠäº¤äº’å¯¹è±¡
  tooltip: null,
  container: null,
  initialized: false,
  raycaster: new THREE.Raycaster(),
  mouse: new THREE.Vector2(),
  INTERSECTED: null, // å½“å‰è¢«é¼ æ ‡æ‚¬åœçš„å¯¹è±¡

  // çŠ¶æ€ç®¡ç†
  _fullData: null, // å­˜å‚¨ä»APIè·å–çš„å®Œæ•´æ˜Ÿç³»æ•°æ®
  _currentView: 'galaxy', // å½“å‰è§†å›¾æ¨¡å¼: 'galaxy' æˆ– 'cluster'
  _currentClusterId: null, // å½“å‰èšç„¦çš„æ˜Ÿå›¢ID

  /**
   * åˆå§‹åŒ–æ¸²æŸ“å™¨ã€‚æ­¤æ–¹æ³•åªåº”æ‰§è¡Œä¸€æ¬¡ã€‚
   * å®ƒä¼šè®¾ç½®åœºæ™¯ã€ç›¸æœºã€æ¸²æŸ“å™¨ã€å…‰ç…§å’Œäº‹ä»¶ç›‘å¬ã€‚
   */
  init: function() {
    if (this.initialized) return;

    // å¥å£®æ€§æ£€æŸ¥ï¼Œç¡®ä¿æ‰€æœ‰å¿…éœ€çš„åº“éƒ½å·²åŠ è½½
    if (typeof THREE === 'undefined' || typeof THREE.OrbitControls === 'undefined' || typeof TWEEN === 'undefined') {
        console.error("Required 3D libraries (THREE, OrbitControls, TWEEN) not loaded. Aborting SpacetimeRenderer.init().");
        const container = document.getElementById('spacetime-container');
        if(container) container.innerHTML = `<div class="flex items-center justify-center h-full text-red-500">åŠ è½½3Dåº“å¤±è´¥ï¼Œè¯·æ£€æŸ¥CDNé“¾æ¥å¹¶åˆ·æ–°é¡µé¢ã€‚</div>`;
        return;
    }

    this.container = document.getElementById('spacetime-container');
    this.tooltip = document.getElementById('spacetime-tooltip');

    if (!this.container || !this.tooltip) {
        console.error("Spacetime container or tooltip not found! Cannot initialize SpacetimeRenderer.");
        return;
    }

    // 1. åœºæ™¯è®¾ç½®
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x0D1117);
    this.scene.fog = new THREE.FogExp2(0x0D1117, 0.005); // ä½¿ç”¨æŒ‡æ•°é›¾ï¼Œæ•ˆæœæ›´è‡ªç„¶

    // 2. ç›¸æœºè®¾ç½®
    this.camera = new THREE.PerspectiveCamera(75, this.container.clientWidth / this.container.clientHeight, 0.1, 1000);
    this.camera.position.set(0, 50, 200); // è°ƒæ•´ç›¸æœºåˆå§‹ä½ç½®ï¼Œæä¾›æ›´å¥½çš„ä¿¯ç°è§†è§’

    // 3. æ¸²æŸ“å™¨è®¾ç½®
    this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
    this.renderer.setPixelRatio(window.devicePixelRatio); // é€‚é…é«˜åˆ†å±
    
    // æ¸…ç©ºå®¹å™¨ï¼Œé˜²æ­¢å› çƒ­é‡è½½ç­‰åŸå› é‡å¤æ·»åŠ canvas
    while (this.container.firstChild && this.container.firstChild.tagName !== 'BUTTON' && this.container.firstChild.id !== 'spacetime-tooltip') {
        this.container.removeChild(this.container.firstChild);
    }
    this.container.appendChild(this.renderer.domElement);

    // 4. æ§åˆ¶å™¨è®¾ç½®
    this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
    this.controls.enableDamping = true;
    this.controls.dampingFactor = 0.05;
    this.controls.minDistance = 50;
    this.controls.maxDistance = 400;
    this.controls.autoRotate = true; // å¢åŠ è‡ªåŠ¨æ—‹è½¬æ•ˆæœ
    this.controls.autoRotateSpeed = 0.2;

    // 5. å…‰ç…§è®¾ç½®
    this.scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const pointLight = new THREE.PointLight(0xffffff, 0.8);
    this.scene.add(pointLight);
    this.camera.add(pointLight); // è®©å…‰æºè·Ÿéšç›¸æœºï¼Œç¡®ä¿å‰æ–¹ç‰©ä½“æ€»èƒ½è¢«ç…§äº®

    // 6. å¯åŠ¨åŠ¨ç”»å¾ªç¯
    const animate = () => {
      requestAnimationFrame(animate);
      TWEEN.update(); // æ›´æ–°TWEENåŠ¨ç”»çŠ¶æ€
      if (this.controls) this.controls.update();
      this._handleIntersections();
      this.renderer.render(this.scene, this.camera);
    };
    animate();

    // 7. ç»‘å®šäº‹ä»¶ç›‘å¬
    window.addEventListener('resize', this.onWindowResize.bind(this));
    this.container.addEventListener('mousemove', this._onMouseMove.bind(this));
    this.container.addEventListener('click', this._onMouseClick.bind(this));
    
    document.getElementById('galaxy-back-btn')?.addEventListener('click', () => this.displayGalaxyView());

    this.initialized = true;
    console.log("SpacetimeRenderer initialized successfully.");
  },

    // --- æ–°å¢ï¼šåˆ›å»ºæ˜Ÿç©ºèƒŒæ™¯çš„å‡½æ•° ---
  _createStarfield: function() {
      const starGeometry = new THREE.BufferGeometry();
      const starMaterial = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 0.5,
          transparent: true,
          opacity: 0.6
      });
      const starVertices = [];
      for (let i = 0; i < 10000; i++) {
          const x = (Math.random() - 0.5) * 2000;
          const y = (Math.random() - 0.5) * 2000;
          const z = (Math.random() - 0.5) * 2000;
          starVertices.push(x, y, z);
      }
      starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
      const stars = new THREE.Points(starGeometry, starMaterial);
      this.scene.add(stars);
  },

  /**
   * å…¬å…±å…¥å£ï¼šæ¥æ”¶æ•°æ®å¹¶æ˜¾ç¤ºé»˜è®¤çš„æ˜Ÿç³»è§†å›¾ã€‚
   * @param {object} data - åŒ…å« nodes å’Œ edges çš„å®Œæ•´æ•°æ®é›†ã€‚
   */
  display: function(data) {
    this.init();
    if (!this.initialized) return;
    this._fullData = data;
    this.displayGalaxyView();
  },

  /**
   * æ˜¾ç¤ºå®è§‚çš„æ˜Ÿç³»è§†å›¾ã€‚
   * ä¼šæ¸²æŸ“æ‰€æœ‰çš„â€œæ˜Ÿå›¢â€å’Œâ€œç²’å­â€ï¼Œä»¥åŠæ˜Ÿå›¢é—´çš„è¿çº¿ã€‚
   */
  displayGalaxyView: function() {
    this._currentView = 'galaxy';
    this._currentClusterId = null;
    document.getElementById('galaxy-back-btn').classList.add('hidden');
    
    const nodesToRender = this._fullData.nodes; // æ˜¾ç¤ºæ‰€æœ‰èŠ‚ç‚¹
    const edgesToRender = this._fullData.edges; // æ˜¾ç¤ºæ‰€æœ‰è¾¹
    this._renderScene(nodesToRender, edgesToRender);
    
    this._focusOn(new THREE.Vector3(0, 0, 150), new THREE.Vector3(0, 0, 0));
  },

  /**
   * æ˜¾ç¤ºèšç„¦çš„æ˜Ÿå›¢è§†å›¾ã€‚
   * åªä¼šæ¸²æŸ“æŒ‡å®šæ˜Ÿå›¢å†…éƒ¨çš„â€œç²’å­â€ã€‚
   * @param {string} clusterId - è¦é’»å–è¿›å…¥çš„æ˜Ÿå›¢IDã€‚
   */
  displayClusterView: function(clusterId) {
    this._currentView = 'cluster';
    this._currentClusterId = clusterId;
    document.getElementById('galaxy-back-btn').classList.remove('hidden');
    
    const clusterNode = this._fullData.nodes.find(n => n.id === clusterId);
    const particleNodes = this._fullData.nodes.filter(n => n.parentId === clusterId);
    this._renderScene(particleNodes); // åªæ¸²æŸ“è¯¥æ˜Ÿå›¢å†…éƒ¨çš„ç²’å­ï¼Œä¸æ¸²æŸ“è¾¹
    
    if (clusterNode) {
      this._focusOn(new THREE.Vector3(clusterNode.x, clusterNode.y, clusterNode.z + 50), new THREE.Vector3(clusterNode.x, clusterNode.y, clusterNode.z));
    }
  },

  /**
   * æ ¸å¿ƒæ¸²æŸ“å‡½æ•°ï¼Œæ ¹æ®ä¼ å…¥çš„èŠ‚ç‚¹å’Œè¾¹æ•°æ®æ›´æ–°åœºæ™¯ã€‚
   * @param {Array} nodesToRender - éœ€è¦è¢«æ¸²æŸ“çš„èŠ‚ç‚¹æ•°ç»„ã€‚
   * @param {Array} [edgesToRender=[]] - éœ€è¦è¢«æ¸²æŸ“çš„è¾¹æ•°ç»„ã€‚
   */
  _renderScene: function(nodesToRender, edgesToRender = []) {
    // 1. æ¸…ç†æ—§åœºæ™¯ä¸­çš„åŠ¨æ€å¯¹è±¡
    const objectsToRemove = this.scene.children.filter(obj => obj.isMesh || obj.isSprite || obj.isLine);
    objectsToRemove.forEach(obj => {
        this.scene.remove(obj);
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) obj.material.dispose();
    });

    // 2. å¤„ç†æ— æ•°æ®æƒ…å†µ
    if (!nodesToRender || nodesToRender.length === 0) {
      const sprite = new SpriteText("æ­¤è§†å›¾ä¸‹æš‚æ— æ•°æ®", 5, 'rgba(255,255,255,0.5)');
      this.scene.add(sprite);
      return;
    }

    // 3. æ¸²æŸ“èŠ‚ç‚¹
    nodesToRender.forEach(node => {
        // --- è§†è§‰å¢å¼ºï¼šç”¨ Sprite åˆ›å»ºå‘å…‰çš„å…‰æ™•æ•ˆæœ ---
        const haloTexture = new THREE.CanvasTexture(this._createHaloCanvas(node.color || '#ffffff'));
        const haloMaterial = new THREE.SpriteMaterial({ map: haloTexture, blending: THREE.AdditiveBlending, depthWrite: false, transparent: true });
        const halo = new THREE.Sprite(haloMaterial);
        halo.scale.set(node.size * 4, node.size * 4, 1); // å…‰æ™•æ¯”èŠ‚ç‚¹å¤§
        halo.position.set(node.x, node.y, node.z);
        halo.userData.isDynamic = true;
        this.scene.add(halo);

        // åˆ›å»ºæ ¸å¿ƒèŠ‚ç‚¹çƒä½“
        const geometry = new THREE.SphereGeometry(node.size, 32, 32);
        const material = new THREE.MeshPhongMaterial({
            color: new THREE.Color(node.color || 0x007bff),
            emissive: new THREE.Color(node.color || 0x007bff).multiplyScalar(0.3),
            transparent: true, opacity: 0.9,
            shininess: 80
        });
        const sphere = new THREE.Mesh(geometry, material);
        sphere.position.set(node.x, node.y, node.z);
        sphere.userData = { ...node, isDynamic: true };
        this.scene.add(sphere);

        // åˆ›å»ºæ–‡å­—æ ‡ç­¾
        const textSprite = new SpriteText(node.name, 2, '#FFFFFF');
        textSprite.position.set(node.x, node.y + node.size + 3, node.z);
        textSprite.userData.isDynamic = true;
        this.scene.add(textSprite);
    });

    // 4. æ¸²æŸ“è¾¹
    const lineMaterial = new THREE.LineBasicMaterial({ color: 0xADD8E6, transparent: true, opacity: 0.2 });
    edgesToRender.forEach(edge => {
        const sourceNode = this._fullData.nodes.find(n => n.id === edge.source);
        const targetNode = this._fullData.nodes.find(n => n.id === edge.target);
        if (sourceNode && targetNode) {
            const path = new THREE.LineCurve3(new THREE.Vector3(sourceNode.x, sourceNode.y, sourceNode.z), new THREE.Vector3(targetNode.x, targetNode.y, targetNode.z));
            const tubeGeometry = new THREE.TubeGeometry(path, 2, 0.1, 8, false);
            const tubeMaterial = new THREE.MeshBasicMaterial({ color: 0x4A5568, transparent: true, opacity: 0.3 });
            const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
            tube.userData.isDynamic = true;
            this.scene.add(tube);
        }
    });
  },

  // --- æ–°å¢ï¼šåˆ›å»ºå…‰æ™•çº¹ç†çš„è¾…åŠ©å‡½æ•° ---
  _createHaloCanvas: function(color) {
      const canvas = document.createElement('canvas');
      canvas.width = 128;
      canvas.height = 128;
      const context = canvas.getContext('2d');
      const gradient = context.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
      gradient.addColorStop(0, `rgba(${new THREE.Color(color).r*255}, ${new THREE.Color(color).g*255}, ${new THREE.Color(color).b*255}, 0.5)`);
      gradient.addColorStop(1, 'rgba(0,0,0,0)');
      context.fillStyle = gradient;
      context.fillRect(0, 0, canvas.width, canvas.height);
      return canvas;
  },

  /**
   * å¤„ç†ç‚¹å‡»äº‹ä»¶ï¼Œæ ¹æ®ç‚¹å‡»å¯¹è±¡çš„ç±»å‹æ‰§è¡Œä¸åŒæ“ä½œã€‚
   */
  _onMouseClick: function() {
    if (this.INTERSECTED) {
      const nodeData = this.INTERSECTED.userData;
      if (nodeData.type === 'cluster') {
        this.displayClusterView(nodeData.id);
      } else if (nodeData.type === 'particle') {
        this._showParticleDetails(nodeData);
      }
    }
  },

  /**
   * æ˜¾ç¤ºç²’å­è¯¦æƒ…ï¼ˆå½“å‰ä¸ºä¸´æ—¶å®ç°ï¼‰ã€‚
   * @param {object} particleData - ç²’å­èŠ‚ç‚¹çš„æ•°æ®ã€‚
   */
  _showParticleDetails: function(particleData) {
    uiUtils.showToast(`ç²’å­: ${particleData.name}`, 'info');
    if (particleData.url && particleData.url !== '#') {
       setTimeout(()=> window.open(particleData.url, '_blank'), 300);
    }
  },
  
  /**
   * ä½¿ç”¨ TWEEN.js å®ç°å¹³æ»‘çš„é•œå¤´åŠ¨ç”»ã€‚
   * @param {THREE.Vector3} newCameraPosition - ç›¸æœºçš„æ–°ç›®æ ‡ä½ç½®ã€‚
   * @param {THREE.Vector3} newTargetPosition - æ§åˆ¶å™¨çš„æ–°ç›®æ ‡ä¸­å¿ƒç‚¹ã€‚
   */
  _focusOn: function(newCameraPosition, newTargetPosition) {
    new TWEEN.Tween(this.camera.position)
        .to(newCameraPosition, 1000)
        .easing(TWEEN.Easing.Cubic.Out)
        .start();

    new TWEEN.Tween(this.controls.target)
        .to(newTargetPosition, 1000)
        .easing(TWEEN.Easing.Cubic.Out)
        .start();
  },

  /**
   * å“åº”çª—å£å¤§å°å˜åŒ–ã€‚
   */
  onWindowResize: function() {
    if (this.container && this.camera && this.renderer) {
      this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
    }
  },

  /**
   * æ›´æ–°é¼ æ ‡åœ¨æ ‡å‡†åŒ–è®¾å¤‡åæ ‡ä¸­çš„ä½ç½®ã€‚
   */
  _onMouseMove: function(event) {
    const rect = this.container.getBoundingClientRect();
    this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

    this.tooltip.style.left = (event.clientX + 15) + 'px';
    this.tooltip.style.top = (event.clientY + 15) + 'px';
  },

  /**
   * å¤„ç†é¼ æ ‡æ‚¬åœäº¤äº’ï¼Œé«˜äº®èŠ‚ç‚¹å¹¶æ˜¾ç¤º/éšè—æç¤ºã€‚
   */
  _handleIntersections: function() {
    if (!this.scene || !this.camera || !this.raycaster) return;

    this.raycaster.setFromCamera(this.mouse, this.camera);
    const intersects = this.raycaster.intersectObjects(this.scene.children.filter(obj => obj.isMesh), true);

    if (intersects.length > 0) {
      const newIntersected = intersects[0].object;
      if (this.INTERSECTED !== newIntersected) {
        if (this.INTERSECTED) {
          this.INTERSECTED.material.emissive.setHex(this.INTERSECTED.currentHex);
          this.INTERSECTED.scale.set(1, 1, 1);
        }
        this.INTERSECTED = newIntersected;
        this.INTERSECTED.currentHex = this.INTERSECTED.material.emissive.getHex();
        this.INTERSECTED.material.emissive.setHex(0x555555);
        this.INTERSECTED.scale.set(1.1, 1.1, 1.1);

        this.tooltip.innerHTML = `<strong>${this.INTERSECTED.userData.name}</strong><br/>ç±»å‹: ${this.INTERSECTED.userData.type}<br/>æ‘˜è¦: ${this.INTERSECTED.userData.summary.substring(0, Math.min(this.INTERSECTED.userData.summary.length, 50))}...`;
        this.tooltip.style.display = 'block';
        this.container.style.cursor = 'pointer';
      }
    } else {
      if (this.INTERSECTED) {
        this.INTERSECTED.material.emissive.setHex(this.INTERSECTED.currentHex);
        this.INTERSECTED.scale.set(1, 1, 1);
      }
      this.INTERSECTED = null;
      this.tooltip.style.display = 'none';
      this.container.style.cursor = 'grab';
    }
  },
};

const ExplorationPage = (() => {
  let _isInitialized = false;
  let _currentInputMode = 'keyword';
  let _currentActiveTabContentManager = null;

  const INPUT_MODES = {
    keyword: { icon: 'ğŸ”', label: 'å…³é”®è¯', placeholder: 'è¾“å…¥å…³é”®è¯ï¼Œå¦‚ AI...', buttonText: 'æ¢ç´¢', inputType: 'text' },
    url: { icon: 'ğŸ”—', label: 'URL', placeholder: 'ç²˜è´´ä¸€ä¸ªç½‘é¡µé“¾æ¥ (URL)...', buttonText: 'åˆ†æ', inputType: 'url' },
    file: { icon: 'ğŸ“„', label: 'æ–‡ä»¶', placeholder: 'ç‚¹å‡»é€‰æ‹©æˆ–æ‹–æ‹½æ–‡ä»¶ (.txt, .pdf, .mp4)', buttonText: 'ä¸Šä¼ ', inputType: 'file' }
  };

  function init() {
    if (_isInitialized) {
        console.log("ExplorationPage already initialized.");
        return;
    }
    
    _createHud();
    _bindHudEventListeners();
    _switchInputMode('keyword');

    _setupExploreTabs();

    _isInitialized = true;
    console.log("ExplorationPage initialized successfully.");

    const initialTabLink = document.querySelector('.explore-tab-link[data-tab="galaxy"]');
    if (initialTabLink) initialTabLink.click();
  }

    /**
   * åˆ›å»ºå¹¶æ’å…¥æ¢ç´¢HUDçš„HTMLç»“æ„ã€‚
   * å®ƒåº”è¯¥è¢«é™„åŠ åˆ° `body` å…ƒç´ ï¼Œä»¥ç¡®ä¿å…¶å…¨å±€å®šä½ã€‚
   */
  function _createHud() {
    // --- æ ¸å¿ƒä¿®æ­£ï¼šå¦‚æœHUDå·²å­˜åœ¨ï¼Œåˆ™ä¸å†åˆ›å»º ---
    if (document.getElementById('exploration-hud')) {
        return;
    }
    
    const hudContainer = document.createElement('div');
    hudContainer.id = 'exploration-hud';
    hudContainer.className = 'fixed bottom-4 left-1/2 -translate-x-1/2 w-[95%] max-w-4xl p-2 rounded-2xl shadow-2xl z-50 backdrop-blur-md transition-all duration-300';
    hudContainer.style.backgroundColor = 'rgba(23, 37, 60, 0.85)';
    hudContainer.style.borderTop = '1px solid rgba(255, 255, 255, 0.1)';
    
    hudContainer.innerHTML = `
      <div class="flex items-center gap-2">
        <div id="hud-mode-switcher" class="relative">
          <button id="hud-mode-btn" class="flex-shrink-0 px-4 py-2.5 rounded-xl font-semibold bg-black/20 text-white hover:bg-black/40 transition-colors flex items-center">
            <span id="hud-mode-icon" class="mr-2 text-lg"></span>
            <span id="hud-mode-label" class="font-bold"></span> 
            <i class="fa fa-chevron-down ml-2 text-xs opacity-70"></i>
          </button>
          <div id="hud-mode-dropdown" class="absolute bottom-full mb-2 w-48 bg-gray-800/90 backdrop-blur-sm rounded-lg shadow-lg hidden overflow-hidden" style="animation: fadeInScale 0.2s ease-out;">
            ${Object.keys(INPUT_MODES).map(key => `
              <a href="#" class="hud-mode-option flex items-center gap-3 px-4 py-3 text-white hover:bg-blue-500/50 transition-colors" data-mode="${key}">
                <span class="text-lg">${INPUT_MODES[key].icon}</span>
                <span class="font-semibold">${INPUT_MODES[key].label}</span>
              </a>
            `).join('')}
          </div>
        </div>
        <div id="hud-input-area" class="flex-grow relative"></div>
        <div id="hud-action-area">
          <button id="hud-action-btn" class="px-8 py-2.5 rounded-xl bg-primary text-white font-bold shadow-lg hover:bg-blue-700 transition-all transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:scale-100"></button>
        </div>
      </div>
    `;
    document.body.appendChild(hudContainer);
  }


  function _bindHudEventListeners() {
    const modeBtn = document.getElementById('hud-mode-btn');
    const modeDropdown = document.getElementById('hud-mode-dropdown');
    
    modeBtn.addEventListener('click', () => modeDropdown.classList.toggle('hidden'));
    document.addEventListener('click', (e) => {
      if (!modeBtn.parentElement.contains(e.target)) {
        modeDropdown.classList.add('hidden');
      }
    });

    document.querySelectorAll('.hud-mode-option').forEach(option => {
      option.addEventListener('click', (e) => {
        e.preventDefault();
        _switchInputMode(option.dataset.mode);
        modeDropdown.classList.add('hidden');
      });
    });

    document.getElementById('hud-action-btn').addEventListener('click', _handleActionClick);
  }

  function _switchInputMode(mode) {
    _currentInputMode = mode;
    const config = INPUT_MODES[mode];
    
    document.getElementById('hud-mode-icon').textContent = config.icon;
    document.getElementById('hud-mode-label').textContent = config.label;
    document.getElementById('hud-action-btn').textContent = config.buttonText;

    const inputArea = document.getElementById('hud-input-area');
    inputArea.innerHTML = '';

    if (config.inputType === 'text' || config.inputType === 'url') {
      const input = document.createElement('input');
      input.type = config.inputType;
      input.id = 'hud-main-input';
      input.className = 'w-full bg-gray-900/50 text-white border border-gray-600 rounded-lg px-4 py-2.5 focus:ring-2 focus:ring-primary focus:border-primary outline-none placeholder-gray-500';
      input.placeholder = config.placeholder;
      inputArea.appendChild(input);
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') _handleActionClick();
      });
    } else if (config.inputType === 'file') {
      const dropZone = document.createElement('div');
      dropZone.id = 'hud-file-drop-zone';
      dropZone.className = 'w-full bg-gray-900/50 text-gray-400 border-2 border-dashed border-gray-600 rounded-lg px-4 py-2.5 text-center cursor-pointer hover:border-primary hover:text-white transition-colors';
      dropZone.innerHTML = `<span id="drop-zone-label">${config.placeholder}</span>`;
      const fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.id = 'hud-file-input';
      fileInput.className = 'hidden';
      fileInput.accept = '.txt,.pdf,.mp4';
      
      dropZone.appendChild(fileInput);
      inputArea.appendChild(dropZone);

      dropZone.addEventListener('click', () => fileInput.click());
      dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('border-primary', 'text-white'); });
      dropZone.addEventListener('dragleave', () => dropZone.classList.remove('border-primary', 'text-white'));
      dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.classList.remove('border-primary', 'text-white');
        if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
          fileInput.files = e.dataTransfer.files;
          document.getElementById('drop-zone-label').textContent = fileInput.files[0].name;
        }
      });
      fileInput.addEventListener('change', () => {
        if (fileInput.files.length > 0) {
          document.getElementById('drop-zone-label').textContent = fileInput.files[0].name;
        }
      });
    }
  }

  async function _handleActionClick() {
    const actionBtn = document.getElementById('hud-action-btn');
    actionBtn.disabled = true;
    
    if (!_currentActiveTabContentManager) {
        uiUtils.showToast('é¡µé¢æœªå®Œå…¨åŠ è½½ï¼Œè¯·ç¨åå†è¯•ã€‚', 'error');
        actionBtn.disabled = false;
        return;
    }

    try {
        switch (_currentInputMode) {
          case 'keyword':
            const keyword = document.getElementById('hud-main-input').value;
            if (!keyword) { uiUtils.showToast('è¯·è¾“å…¥å…³é”®è¯', 'error'); break; }
            if (_currentActiveTabContentManager.handleKeywordSearch) {
                await _currentActiveTabContentManager.handleKeywordSearch(keyword);
            } else {
                uiUtils.showToast('å½“å‰è§†å›¾ä¸æ”¯æŒå…³é”®è¯æœç´¢ã€‚', 'info');
            }
            break;
          case 'url':
            const url = document.getElementById('hud-main-input').value;
            if (!url || !url.startsWith('http')) { uiUtils.showToast('è¯·è¾“å…¥æœ‰æ•ˆçš„URL', 'error'); break; }
            if (_currentActiveTabContentManager.handleUrlAnalysis) {
                await _currentActiveTabContentManager.handleUrlAnalysis(url);
            } else {
                 uiUtils.showToast('å½“å‰è§†å›¾ä¸æ”¯æŒURLåˆ†æã€‚', 'info');
            }
            break;
          case 'file':
            const fileInput = document.getElementById('hud-file-input');
            if (!fileInput.files || fileInput.files.length === 0) { uiUtils.showToast('è¯·é€‰æ‹©ä¸€ä¸ªæ–‡ä»¶', 'error'); break; }
            if (_currentActiveTabContentManager.handleFileUpload) {
                await _currentActiveTabContentManager.handleFileUpload(fileInput.files[0]);
            } else {
                 uiUtils.showToast('å½“å‰è§†å›¾ä¸æ”¯æŒæ–‡ä»¶ä¸Šä¼ ã€‚', 'info');
            }
            break;
        }
    } catch (e) {
        console.error("HUD action failed:", e);
        uiUtils.showToast(`æ“ä½œå¤±è´¥: ${e.message}`, 'error');
    } finally {
        actionBtn.disabled = false;
    }
  }

  function _setupExploreTabs() {
    document.querySelectorAll('.explore-tab-link').forEach(tabLink => {
      tabLink.addEventListener('click', async (event) => {
        event.preventDefault();

        const targetTabId = event.currentTarget.dataset.tab;

        document.querySelectorAll('.explore-tab-link').forEach(link => {
          link.classList.remove('active', 'border-primary', 'text-primary');
          link.classList.add('border-transparent', 'text-gray-300');
        });

        document.querySelectorAll('.explore-tab-content').forEach(content => {
          content.classList.add('hidden');
        });

        event.currentTarget.classList.add('active', 'border-primary', 'text-primary');
        event.currentTarget.classList.remove('border-transparent', 'text-gray-300');

        const contentToShow = document.getElementById(`explore-${targetTabId}-content`);
        if (contentToShow) {
          contentToShow.classList.remove('hidden');
        }
        console.log(`Switched to exploration sub-tab: ${targetTabId}`);

        switch (targetTabId) {
          case 'galaxy':
            _currentActiveTabContentManager = await _initGalaxyContent();
            break;
          case 'feeds':
            _currentActiveTabContentManager = await _initFeedsContent();
            break;
          case 'explorer':
            _currentActiveTabContentManager = await _initExplorerContent();
            break;
          default:
            console.error(`æœªçŸ¥æˆ–æœªå®ç°çš„æ¢ç´¢å­æ ‡ç­¾: ${targetTabId}`);
            _currentActiveTabContentManager = null;
        }
      });
    });
  }

  async function _initGalaxyContent() {
    console.log("Initializing Galaxy Map Content...");
    const container = document.getElementById('spacetime-container');
    const loadingSpinner = container.querySelector('.absolute.inset-0');
    if (loadingSpinner) loadingSpinner.style.display = 'flex';

    try {
      SpacetimeRenderer.init(); 
      if (!SpacetimeRenderer.initialized) {
          throw new Error("SpacetimeRenderer failed to initialize.");
      }
      const galaxyData = await App.callApi('ExplorationService', 'getGalaxyMapData');
      SpacetimeRenderer.display(galaxyData);

      return {
        handleKeywordSearch: async (keyword) => {
          uiUtils.showToast(`æ­£åœ¨å…¨åŸŸæ˜Ÿå›¾ä¸­æœç´¢å¹¶é«˜äº® "${keyword}"...`, 'info');
          const filteredData = await App.callApi('ExplorationService', 'filterGalaxyMap', [keyword]);
          SpacetimeRenderer.display(filteredData);
        },
        handleUrlAnalysis: async (url) => {
             uiUtils.showToast(`å…¨åŸŸæ˜Ÿå›¾å¼€å§‹åˆ†æURL: ${url}`, 'info');
             const result = await App.callApi('ExplorationService', 'analyzeUrl', [url]);
             const currentData = await App.callApi('ExplorationService', 'getGalaxyMapData');
             const newParticle = {
                id: `url_particle_${Date.now()}`,
                name: result.finalRecord.title.substring(0, Math.min(result.finalRecord.title.length, 20)) + '...',
                type: 'particle', category: 'URL Analysis', heat: 0.7, relevance: 0.7,
                summary: result.finalRecord.ai_summary,
                x: Math.random() * 100 - 50, y: Math.random() * 100 - 50, z: Math.random() * 100 - 50,
                size: 4, color: '#FFD700', url: url
             };
             currentData.nodes.push(newParticle);
             SpacetimeRenderer.display(currentData);
             uiUtils.showToast('URLåˆ†æç»“æœå·²æ·»åŠ åˆ°å…¨åŸŸæ˜Ÿå›¾ã€‚', 'success');
        },
        handleFileUpload: async (file) => {
            uiUtils.showToast(`å…¨åŸŸæ˜Ÿå›¾å¼€å§‹ä¸Šä¼ æ–‡ä»¶: ${file.name}`, 'info');
            const { uploadId } = await App.callApi('ExplorationService', 'startFileUpload', [file.name, file.type]);
            const { jobId } = await App.callApi('ExplorationService', 'finishFileUpload', [uploadId]);
            let analysisResult = null;
            const pollInterval = setInterval(async () => {
                const statusResult = await App.callApi('ExplorationService', 'getAnalysisStatus', [jobId]);
                if (statusResult.status === 'Completed') {
                    clearInterval(pollInterval);
                    analysisResult = statusResult.result;
                    const currentData = await App.callApi('ExplorationService', 'getGalaxyMapData');
                    const newParticle = {
                        id: `file_particle_${Date.now()}`,
                        name: analysisResult.title.substring(0, Math.min(analysisResult.title.length, 20)) + '...',
                        type: 'particle', category: 'File Analysis', heat: 0.75, relevance: 0.8,
                        summary: analysisResult.ai_summary,
                        x: Math.random() * 100 - 50, y: Math.random() * 100 - 50, z: Math.random() * 100 - 50,
                        size: 4.5, color: '#DAA520', url: '#'
                    };
                    currentData.nodes.push(newParticle);
                    SpacetimeRenderer.display(currentData);
                    uiUtils.showToast('æ–‡ä»¶åˆ†æç»“æœå·²æ·»åŠ åˆ°å…¨åŸŸæ˜Ÿå›¾ã€‚', 'success');
                } else if (statusResult.status === 'Failed' || statusResult.status === 'NotFound') {
                    clearInterval(pollInterval);
                    uiUtils.showToast('æ–‡ä»¶åˆ†æå¤±è´¥ã€‚', 'error');
                }
            }, 1500);
        }
      };
    } catch (error) {
      console.error("Failed to load Galaxy Map data:", error);
      container.innerHTML = `<div class="flex items-center justify-center h-full text-red-500">åŠ è½½å…¨åŸŸæ˜Ÿå›¾å¤±è´¥: ${error.message}</div>`;
      return null;
    } finally {
      if (loadingSpinner) loadingSpinner.style.display = 'none';
    }
  }

  async function _initFeedsContent() {
    console.log("Initializing Topic Feeds Content...");
    const topicSelector = document.getElementById('feeds-topic-selector');
    const feedsMatrixContainer = document.getElementById('feeds-matrix-container');

    _bindMatrixContainerEvents(feedsMatrixContainer);

    feedsMatrixContainer.innerHTML = `
      <div class="col-span-full flex items-center justify-center h-full bg-gray-900/50 rounded-xl text-gray-400 text-lg border border-gray-700">
        <i class="fa fa-spinner fa-spin mr-3"></i> æ­£åœ¨åŠ è½½ä¸»é¢˜...
      </div>
    `;

    try {
      const popularTopics = await App.callApi('ExplorationService', 'getPopularTopics');
      if (topicSelector.tomselect) {
          topicSelector.tomselect.destroy();
      }
      const tomSelectInstance = new TomSelect(topicSelector, {
        options: popularTopics,
        valueField: 'id',
        labelField: 'name',
        searchField: 'name',
        plugins: ['remove_button'],
        maxItems: 4,
        placeholder: 'æœç´¢æˆ–é€‰æ‹©ä¸»é¢˜...'
      });

      tomSelectInstance.on('change', async (selectedTopicIds) => {
        await _renderFeedsMatrix(selectedTopicIds);
      });

      const initialSelectedTopics = tomSelectInstance.getValue();
      await _renderFeedsMatrix(initialSelectedTopics);

      return {
        handleKeywordSearch: async (keyword) => {
          uiUtils.showToast(`æ­£åœ¨ä¿¡æ¯æµä¸­æœç´¢å¹¶é«˜äº® "${keyword}"...`, 'info');
          _filterFeedsClientSide(keyword);
        },
        handleUrlAnalysis: async (url) => {
            uiUtils.showToast(`ä¸»é¢˜ä¿¡æ¯æµä¸æ”¯æŒç›´æ¥URLåˆ†æï¼Œè¯·åˆ‡æ¢åˆ°å…¨åŸŸæ˜Ÿå›¾ã€‚`, 'info');
        },
        handleFileUpload: async (file) => {
            uiUtils.showToast(`ä¸»é¢˜ä¿¡æ¯æµä¸æ”¯æŒç›´æ¥æ–‡ä»¶ä¸Šä¼ ï¼Œè¯·åˆ‡æ¢åˆ°å…¨åŸŸæ˜Ÿå›¾ã€‚`, 'info');
        }
      };
    } catch (error) {
      console.error("Failed to load Topic Feeds data:", error);
      feedsMatrixContainer.innerHTML = `<div class="col-span-full text-red-500 text-center py-16">åŠ è½½ä¸»é¢˜ä¿¡æ¯æµå¤±è´¥: ${error.message}</div>`;
      return null;
    }
  }

  function _bindMatrixContainerEvents(container) {
    if (!container) return;
    // ç¡®ä¿åªç»‘å®šä¸€æ¬¡ï¼Œé˜²æ­¢é‡å¤ç›‘å¬
    if (container.dataset.eventsBound) return;

    container.addEventListener('click', async (e) => {
        // ä»è¢«ç‚¹å‡»çš„å…ƒç´ å¼€å§‹ï¼Œå‘ä¸ŠæŸ¥æ‰¾æœ€è¿‘çš„ .feed-item-card
        const card = e.target.closest('.feed-item-card');
        
        if (card) {
            e.preventDefault(); // å¦‚æœå¡ç‰‡æ˜¯<a>æ ‡ç­¾ï¼Œé˜»æ­¢å…¶é»˜è®¤è·³è½¬è¡Œä¸º
            
            // è¯»å– data-feed-item-id å±æ€§ã€‚HTMLä¸­çš„ kebab-case ä¼šè¢«è‡ªåŠ¨è½¬æ¢ä¸º camelCase
            const feedId = card.dataset.feedItemId; 
            
            if (!feedId) {
                console.error("Card clicked, but data-feed-item-id attribute is missing or empty.", card);
                return;
            }

            console.log(`Card clicked, feedId: ${feedId}`); // è°ƒè¯•æ—¥å¿—

            try {
                uiUtils.showToast('æ­£åœ¨åŠ è½½è¯¦æƒ…...', 'info');
                const details = await App.callApi('ExplorationService', 'getFeedItemDetails', [feedId]);
                
                if (details && !details.error) {
                    // è°ƒç”¨é€šç”¨çš„ä¾§è¾¹æ æœåŠ¡æ¥æ˜¾ç¤ºè¯¦æƒ…
                    uiUtils.showDetailsSidePanel(details.title, details, details.sourceUrl);
                } else {
                    throw new Error(details.error || `æœªæ‰¾åˆ° ID ä¸º ${feedId} çš„ä¿¡æ¯`);
                }
            } catch (error) {
                console.error("Failed to get feed item details:", error);
                uiUtils.showToast(`åŠ è½½è¯¦æƒ…å¤±è´¥: ${error.message}`, 'error');
            }
        }
    });

    // ä¸ºå®¹å™¨æ·»åŠ ä¸€ä¸ªæ ‡è®°ï¼Œè¡¨ç¤ºäº‹ä»¶å·²ç»ç»‘å®š
    container.dataset.eventsBound = 'true';
  }

  async function _renderFeedsMatrix(selectedTopicIds) {
    const feedsMatrixContainer = document.getElementById('feeds-matrix-container');
    if (!feedsMatrixContainer) return;

    // æ¸…ç©ºç°æœ‰å†…å®¹å¹¶æ˜¾ç¤ºåŠ è½½åŠ¨ç”»
    feedsMatrixContainer.innerHTML = `
      <div class="col-span-full flex items-center justify-center h-full bg-gray-900/50 rounded-xl text-gray-400 text-lg border border-gray-700">
        <i class="fa fa-spinner fa-spin mr-3"></i> æ­£åœ¨åŠ è½½ä¿¡æ¯æµ...
      </div>
    `;

    if (!selectedTopicIds || selectedTopicIds.length === 0) {
        feedsMatrixContainer.innerHTML = `
          <div class="col-span-full flex items-center justify-center h-full bg-gray-900/50 rounded-xl text-gray-400 text-lg border border-gray-700">
            ğŸ‘‹ è¯·ä»å·¦ä¾§é€‰æ‹©ä¸»é¢˜ä»¥åŠ è½½ä¿¡æ¯æµã€‚
          </div>
        `;
        return;
    }

    try {
      const { feeds } = await App.callApi('ExplorationService', 'getFeedDataByTopics', [selectedTopicIds]); 

      feedsMatrixContainer.innerHTML = ''; // å‡†å¤‡æ¸²æŸ“çœŸå®å†…å®¹å‰ï¼Œå†æ¬¡æ¸…ç©º
      
      let gridColsClass = 'lg:grid-cols-1';
      if (selectedTopicIds.length === 2) gridColsClass = 'lg:grid-cols-2';
      else if (selectedTopicIds.length === 3) gridColsClass = 'lg:grid-cols-3';
      else if (selectedTopicIds.length >= 4) gridColsClass = 'lg:grid-cols-4';
      feedsMatrixContainer.className = `lg:flex-1 grid gap-6 min-h-[400px] grid-cols-1 md:grid-cols-2 ${gridColsClass}`; 

      selectedTopicIds.forEach(topicId => {
        const topicName = document.querySelector(`#feeds-topic-selector option[value="${topicId}"]`)?.textContent || topicId;
        const feedItems = feeds[topicId] || [];
        const feedColumn = document.createElement('div');
        
        feedColumn.className = 'flex flex-col bg-gray-800/50 rounded-xl shadow-lg border border-gray-700 p-4';
        feedColumn.innerHTML = `
          <h4 class="font-bold text-lg text-primary mb-3 flex-shrink-0">${topicName}</h4>
          <div class="flex-1 overflow-y-auto space-y-3 pr-2 -mr-2">
            ${feedItems.length > 0 ? feedItems.map(item => `
              <div class="bg-gray-900/50 p-3 rounded-lg border border-transparent hover:border-blue-700 cursor-pointer transition-colors duration-300 feed-item-card" 
                   data-feed-item-id="${item.id}">
                <p class="font-semibold text-gray-200">${item.title}</p>
                <p class="text-sm text-gray-400 mt-1 line-clamp-2">${item.summary}</p>
                <div class="flex justify-between items-center text-xs text-gray-500 mt-2">
                  <span>${item.sourceType}</span>
                  <span>${formatDateForDisplay(item.publicationDate)}</span>
                </div>
              </div>
            `).join('') : '<p class="text-gray-500 text-sm text-center py-8">æš‚æ— ç›¸å…³ä¿¡æ¯ã€‚</p>'}
          </div>
        `;
        feedsMatrixContainer.appendChild(feedColumn);
      });

    } catch (error) {
      console.error("Failed to render Feeds Matrix:", error);
      feedsMatrixContainer.innerHTML = `<div class="col-span-full text-red-500 text-center py-16">åŠ è½½ä¿¡æ¯æµå¤±è´¥: ${error.message}</div>`;
    }
  }

  function _filterFeedsClientSide(keyword) {
    const normalizedKeyword = keyword.toLowerCase();
    let foundMatch = false;
    document.querySelectorAll('#feeds-matrix-container .feed-item-card').forEach(itemEl => {
        const title = itemEl.querySelector('p:first-child').textContent;
        const summary = itemEl.querySelector('p:nth-child(2)').textContent;
        if (title.toLowerCase().includes(normalizedKeyword) || summary.toLowerCase().includes(normalizedKeyword)) {
            itemEl.classList.add('border-blue-500', 'ring-2', 'ring-blue-500');
            foundMatch = true;
        } else {
            itemEl.classList.remove('border-blue-500', 'ring-2', 'ring-blue-500');
        }
    });
    if (!foundMatch && normalizedKeyword) {
        uiUtils.showToast(`æœªåœ¨å½“å‰ä¿¡æ¯æµä¸­æ‰¾åˆ°ä¸ "${keyword}" ç›¸å…³çš„é¡¹ã€‚`, 'info');
    }
  }

  async function _initExplorerContent() {
    console.log("Initializing Entity Explorer Content...");
    const entityGrid = document.getElementById('explorer-entity-grid');
    const applyFilterBtn = document.getElementById('explorer-apply-filter-btn');
    const resetFilterBtn = document.getElementById('explorer-reset-filter-btn');
    const entityTypeSelect = document.getElementById('explorer-entity-type');
    const industryInput = document.getElementById('explorer-industry');
    const statusSelect = document.getElementById('explorer-status');
    const locationInput = document.getElementById('explorer-location');

    if (entityGrid && !entityGrid.dataset.eventsBound) {
      entityGrid.addEventListener('click', async (e) => {
          const card = e.target.closest('.interactive-card');
          if (card) {
              const entityId = card.dataset.entityId;
              if (!entityId) return;

              try {
                  const details = await App.callApi('DashboardService', 'getSidePanelData', [entityId]);
                  // å¤ç”¨ Dashboard çš„ä¾§è¾¹æ æ¥æ˜¾ç¤ºè¯¦æƒ…
                  uiUtils.showDetailsSidePanel(details.entity_name, details, details.source_url);
              } catch (error) {
                  uiUtils.showToast(`åŠ è½½å®ä½“è¯¦æƒ…å¤±è´¥: ${error.message}`, 'error');
              }
          }
      });
      entityGrid.dataset.eventsBound = 'true';
    }

    try {
      const filterOptions = await App.callApi('ExplorationService', 'getEntityFilterOptions');
      entityTypeSelect.innerHTML = '<option value="">æ‰€æœ‰ç±»å‹</option>';
      filterOptions.entityTypes.forEach(type => {
        const option = document.createElement('option');
        option.value = type;
        option.textContent = type;
        entityTypeSelect.appendChild(option);
      });
    } catch (error) {
      console.error("Failed to load entity filter options:", error);
    }

    applyFilterBtn.onclick = async () => {
      await _applyEntityFilters();
    };
    resetFilterBtn.onclick = async () => {
      entityTypeSelect.value = '';
      industryInput.value = '';
      statusSelect.value = '';
      locationInput.value = '';
      await _applyEntityFilters();
    };

    await _applyEntityFilters();

    return {
      handleKeywordSearch: async (keyword) => {
        industryInput.value = keyword;
        await _applyEntityFilters();
        uiUtils.showToast(`å·²åœ¨å®ä½“æµè§ˆå™¨ä¸­æœç´¢ "${keyword}"`, 'info');
      },
      handleUrlAnalysis: async (url) => {
            uiUtils.showToast(`å®ä½“æµè§ˆå™¨ä¸æ”¯æŒç›´æ¥URLåˆ†æï¼Œè¯·åˆ‡æ¢åˆ°å…¨åŸŸæ˜Ÿå›¾ã€‚`, 'info');
        },
      handleFileUpload: async (file) => {
            uiUtils.showToast(`å®ä½“æµè§ˆå™¨ä¸æ”¯æŒç›´æ¥æ–‡ä»¶ä¸Šä¼ ï¼Œè¯·åˆ‡æ¢åˆ°å…¨åŸŸæ˜Ÿå›¾ã€‚`, 'info');
        }
    };
  }

  async function _applyEntityFilters() {
    const entityGrid = document.getElementById('explorer-entity-grid');
    const entityType = document.getElementById('explorer-entity-type').value;
    const industry = document.getElementById('explorer-industry').value;
    const status = document.getElementById('explorer-status').value;
    const location = document.getElementById('explorer-location').value;
    const pagination = { page: 1, limit: 9 };

    entityGrid.innerHTML = `
      <div class="col-span-full text-center py-16 text-gray-400">
        <i class="fa fa-spinner fa-spin text-5xl mb-4"></i>
        <p class="text-lg">æ­£åœ¨åŠ è½½å®ä½“...</p>
      </div>
    `;

    try {
      const filters = { type: entityType, industry: industry, status: status, location: location };
      const { records, totalRecords } = await App.callApi('ExplorationService', 'getEntities', [filters, pagination, { field: 'influenceScore', order: 'desc' }]);

      entityGrid.innerHTML = '';

      if (records.length === 0) {
        entityGrid.innerHTML = `
          <div class="col-span-full text-center py-16 text-gray-400">
            <i class="fa fa-frown-o text-5xl mb-4"></i>
            <p class="text-lg">æ²¡æœ‰æ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„å®ä½“ã€‚</p>
          </div>
        `;
        return;
      }

      records.forEach(entity => {
        const card = document.createElement('div');
        // **** è§†è§‰é‡æ„åº”ç”¨ç‚¹ ****
        card.className = 'interactive-card panel p-4 flex flex-col cursor-pointer'; // ä½¿ç”¨ panel å’Œ interactive-card
        card.dataset.entityId = entity.id; // æ·»åŠ  data-entity-id

        card.innerHTML = `
          <div class="flex-grow">
            <h4 class="font-bold text-lg text-primary mb-2">${entity.name}</h4>
            <p class="text-sm text-text-medium mb-3 line-clamp-2 min-h-[40px]">${entity.summary}</p>
            <div class="flex flex-wrap gap-1.5 text-xs mt-auto">
              <span class="inline-flex items-center bg-gray-700 text-gray-300 px-2 py-1 rounded-full font-medium">
                <i class="fa fa-cube mr-1.5"></i>${entity.type}
              </span>
              <span class="inline-flex items-center bg-gray-700 text-gray-300 px-2 py-1 rounded-full font-medium">
                <i class="fa fa-industry mr-1.5"></i>${entity.industry.split(',')[0].trim()}
              </span>
              <span class="badge ${entity.status === 'active' ? 'badge-success' : 'badge-inactive'}">${entity.status === 'active' ? 'æ´»è·ƒ' : 'éæ´»è·ƒ'}</span>
            </div>
          </div>
          <div class="w-full h-12 mt-4 flex-shrink-0" id="micro-chart-${entity.id}"></div>
        `;
        entityGrid.appendChild(card);

        if (entity.microChartData && entity.microChartData.length > 0) {
          const chartDom = document.getElementById(`micro-chart-${entity.id}`);
          if (chartDom && !echarts.getInstanceByDom(chartDom)) {
              const microChart = echarts.init(chartDom);
              const option = {
                grid: { top: 5, left: 5, right: 5, bottom: 5, containLabel: true },
                xAxis: { type: 'category', show: false },
                yAxis: { type: 'value', show: false },
                series: [{
                  data: entity.microChartData,
                  type: 'line',
                  smooth: true,
                  showSymbol: false,
                  lineStyle: { width: 2, color: '#007bff' },
                  areaStyle: {
                    color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{
                      offset: 0, color: 'rgba(0, 123, 255, 0.4)'
                    }, {
                      offset: 1, color: 'rgba(0, 123, 255, 0)'
                    }])
                  }
                }],
                tooltip: { trigger: 'axis', axisPointer: { type: 'shadow' } }
              };
              microChart.setOption(option);
          }
        }
      });

      _explorerPaginationLogic(totalRecords, pagination.limit, pagination.page);

    } catch (error) {
      console.error("Failed to apply entity filters:", error);
      entityGrid.innerHTML = `<div class="col-span-full text-red-500 text-center py-16">åŠ è½½å®ä½“å¤±è´¥: ${error.message}</div>`;
    }
  }

  function _explorerPaginationLogic(totalRecords, itemsPerPage, currentPage) {
      const paginationContainer = document.getElementById('explorer-pagination');
      if (!paginationContainer) return;
      paginationContainer.innerHTML = '';
      const totalPages = Math.ceil(totalRecords / itemsPerPage);

      if (totalPages <= 1) return;

      const prevBtn = document.createElement('button');
      prevBtn.className = 'px-3 py-1 bg-gray-700 text-gray-200 rounded-md hover:bg-gray-600 disabled:opacity-50';
      prevBtn.textContent = 'ä¸Šä¸€é¡µ';
      prevBtn.disabled = currentPage === 1;
      prevBtn.onclick = () => { uiUtils.showToast('åˆ†é¡µåŠŸèƒ½å¾…å®ç°', 'info'); };

      const nextBtn = document.createElement('button');
      nextBtn.className = 'px-3 py-1 bg-gray-700 text-gray-200 rounded-md hover:bg-gray-600 disabled:opacity-50';
      nextBtn.textContent = 'ä¸‹ä¸€é¡µ';
      nextBtn.disabled = currentPage >= totalPages;
      nextBtn.onclick = () => { uiUtils.showToast('åˆ†é¡µåŠŸèƒ½å¾…å®ç°', 'info'); };

      const infoSpan = document.createElement('span');
      infoSpan.className = 'text-gray-400 text-sm';
      infoSpan.textContent = `ç¬¬ ${currentPage} / ${totalPages} é¡µ (å…± ${totalRecords} æ¡)`;

      paginationContainer.appendChild(prevBtn);
      paginationContainer.appendChild(infoSpan);
      paginationContainer.appendChild(nextBtn);
  }

  function formatDateForDisplay(dateString) {
    if (!dateString) return 'N/A';
    try {
      const dateObj = new Date(dateString);
      if (isNaN(dateObj.getTime())) return 'Invalid Date';
      const year = dateObj.getFullYear();
      const month = String(dateObj.getMonth() + 1).padStart(2, '0');
      const day = String(dateObj.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    } catch (e) {
      console.error("Error formatting date:", dateString, e);
      return 'Format Error';
    }
  }

  return {
    init: init
  };
})();
</script>
