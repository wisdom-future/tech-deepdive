Jason，太好了！现在我们来把这个“自适应外部数据源”的系统设计方案进行系统化梳理，明确其架构、数据流、核心组件以及所采用的设计模式，并配上设计图，确保我们对齐到每一个细节。

---

### **《自适应外部数据源系统设计方案》**

**一、**引言**

在当前快速变化的技术情报领域，数据来源的多样性、API 接口的异构性以及外部服务的不稳定性，对情报系统的灵活性和可维护性提出了巨大挑战。传统硬编码数据源的方式导致系统难以扩展、维护成本高昂。

本方案旨在设计并实现一个高度可配置、可扩展的“自适应外部数据源管理系统”，将外部数据源的连接“协议”数据化，从而使系统能够动态地适应各种 API 请求和响应模式，实现“源头不断丰富，数据越来越丰富”的目标，而无需频繁修改核心业务逻辑代码。

---

**二、**核心设计理念**

1.  **配置即数据 (Configuration as Data)**：将外部数据源的所有连接元数据（URL、请求方法、认证方式、请求/响应格式、固定参数等）存储在数据库中，而非硬编码在代码中。
2.  **协议适配 (Protocol Adaptation)**：构建一个通用的数据连接器，能够根据数据库中存储的“协议”元数据，动态地构建和执行 HTTP 请求，并解析响应。
3.  **高度解耦 (High Decoupling)**：将业务逻辑（如数据采集工作流）与外部数据源的具体实现细节彻底分离，业务逻辑只需声明其所需的数据类型，而无需关心数据从何而来、如何获取。
4.  **集中管理 (Centralized Management)**：提供统一的用户界面，方便用户对所有外部数据源进行配置、监控和管理。
5.  **可扩展性 (Extensibility)**：系统能够轻松地接入新的数据源，只需更新配置数据即可，最大限度地减少代码修改。

---

**三、**系统架构设计图**

为了清晰地展示各组件之间的关系和数据流，以下是本方案的系统架构设计图：

```mermaid
graph TD
    subgraph Frontend (用户界面)
        A[系统管理页面] --> B(外部数据源管理 Tab)
        B -- 配置数据 --> C{动态表单生成}
    end

    subgraph Backend (Google Apps Script 服务层)
        D[Service Admin Service] -- 管理 --> E(外部数据源注册表)
        F[Workflows Service] -- 请求数据 --> G(Data Connector)
        H[Insights Service] -- 请求数据 --> G
        I[Reports Service] -- 请求数据 --> G
        G -- 查询/更新 --> E
        G -- 获取 API Key --> J(Script Properties)
    end

    subgraph Database (Google Cloud Firestore)
        E -- 存储/读取 --> K(external_data_sources Collection)
        L[其他数据集合]
    end

    subgraph External (外部世界)
        M(第三方 API 服务)
    end

    A -- "用户操作" --> D
    D -- "CRUD 操作" --> E
    G -- "动态构建请求" --> M
    M -- "API 响应 (JSON/XML/Text)" --> G
    G -- "解析后数据" --> F
    F -- "处理/存储" --> L

    style A fill:#f9f,stroke:#333,stroke-width:2px
    style B fill:#fff,stroke:#333,stroke-width:1px
    style C fill:#ccf,stroke:#333,stroke-width:1px
    style D fill:#fcf,stroke:#333,stroke-width:2px
    style E fill:#fcf,stroke:#333,stroke-width:1px
    style F fill:#fcf,stroke:#333,stroke-width:2px
    style G fill:#fcf,stroke:#333,stroke-width:2px
    style H fill:#fcf,stroke:#333,stroke-width:2px
    style I fill:#fcf,stroke:#333,stroke-width:2px
    style J fill:#fef,stroke:#333,stroke-width:1px
    style K fill:#ddf,stroke:#333,stroke-width:2px
    style L fill:#ddf,stroke:#333,stroke-width:1px
    style M fill:#bfb,stroke:#333,stroke-width:2px
```

**设计图解读：**

*   **用户界面 (Frontend)**：用户通过“系统管理页面”中的“外部数据源管理”Tab 与系统交互。该 Tab 能够根据后端提供的配置元数据，动态生成表单和数据列表。
*   **后端服务层 (Backend)**：
    *   **`SystemAdminService`**：负责管理 `external_data_sources` 集合，处理用户界面的 CRUD 请求。
    *   **`Workflows Service`、`Insights Service`、`Reports Service`**：这些是业务逻辑层，它们不再直接调用外部 API，而是通过 **`DataConnector`** 请求所需数据。
    *   **`DataConnector`**：这是核心的“协议适配器”。它从 `external_data_sources` 集合中读取数据源的详细配置，并从 `Script Properties` 中获取敏感的 API Key。然后，它根据这些配置动态构建 HTTP 请求，发送给“第三方 API 服务”，并接收和解析响应。
*   **数据库 (Google Cloud Firestore)**：
    *   **`external_data_sources Collection`**：专门用于存储所有外部数据源的连接协议和元数据。
    *   **`其他数据集合`**：包括原始数据（RAW_ACADEMIC_PAPERS 等）、情报数据（TECH_INSIGHTS_MASTER）等，这些是业务逻辑处理后的最终数据。
*   **外部世界 (External)**：代表各种第三方 API 服务，如 arXiv、NewsAPI、OpenAI 等。

---

**四、**详细设计方案**

##### **4.1. 外部数据源注册表 (`external_data_sources` Firestore Collection)**

*   **目的**：统一存储所有外部 API 服务的元数据，实现数据驱动的连接配置。
*   **Schema (每个文档的字段)**：

    *   `source_id` (string, required, unique): **唯一标识符**，如 "ARXIV_API", "NEWSAPI_ORG", "OPENAI_LLM", "GITHUB_API"。
    *   `display_name` (string, required): 用户友好的显示名称，如 "arXiv 学术论文 API"。
    *   `source_type` (string, required): **服务类型**，用于工作流查找，是抽象层面的分类。例如：
        *   `"academic_paper_source"`
        *   `"patent_data_source"`
        *   `"news_source"`
        *   `"opensource_data_source"`
        *   `"llm_service"`
        *   `"chart_service"`
        *   `"image_cdn"`
        *   `"other"`
    *   `base_url` (string, required): API 的根 URL，如 "http://export.arxiv.org", "https://api.openai.com"。
    *   `endpoint_paths` (map/object, required): 定义不同逻辑端点的相对路径。
        *   例如：`{"query": "/api/query", "search": "/search"}`。
    *   `request_method` (string, required): 默认的 HTTP 请求方法，枚举值 "GET", "POST", "PUT", "DELETE"。
    *   `payload_type` (string, required): 请求体的数据格式，枚举值 "none", "json", "form_urlencoded", "xml"。
    *   `response_type` (string, required): 预期响应体的数据格式，枚举值 "json", "xml", "text"。
    *   `auth_method` (string, required): 认证方式。
        *   `"none"`: 无认证。
        *   `"header_key"`: API Key 放在自定义 HTTP 头中。
        *   `"query_param_key"`: API Key 放在 URL 查询参数中。
        *   `"bearer_token"`: 标准的 OAuth Bearer Token (API Key 即 Token)。
        *   `"basic_auth"`: Basic Authentication (API Key 存储 "username:password" 的 Base64 编码)。
    *   `api_key_name` (string, optional): 对应 `PropertiesService.getScriptProperties()` 中存储实际 API Key 的键名。如果 `auth_method` 为 `none` 则为 `null`。
    *   `api_key_header_name` (string, optional): 当 `auth_method` 为 `header_key` 或 `bearer_token` 时，指定 HTTP 头部的名称（例如 `X-Api-Key` 或 `Authorization`）。
    *   `api_key_query_param_name` (string, optional): 当 `auth_method` 为 `query_param_key` 时，指定 URL 查询参数的名称。
    *   `request_headers` (map/object, optional): 一个 JSON 对象，包含每次请求该数据源时都需要携带的固定 HTTP 请求头（例如 `{"User-Agent": "MyAgent/1.0", "Accept": "application/json"}`）。
    *   `fixed_query_params` (map/object, optional): 一个 JSON 对象，包含每次请求该数据源时都需要携带的固定 URL 查询参数。
    *   `is_active` (boolean, required): 是否启用该数据源。
    *   `priority` (number, optional): 优先级，数字越大表示优先级越高。在 `getAllActiveSourcesOfType` 场景下，用于选择或排序。
    *   `rate_limit_per_minute` (number, optional): （可选）该数据源的每分钟请求限制，可用于未来的限流模块。
    *   `notes` (string, optional): 备注信息。
    *   `last_successful_check` (timestamp, optional): 最近一次成功连接的时间戳，可由监控工作流更新。
    *   `created_timestamp` (timestamp): 创建时间。
    *   `last_updated_timestamp` (timestamp): 最后更新时间。

##### **4.2. 数据连接器 (`backend/DataConnector.gs`)**

*   **职责**：作为所有工作流与外部 API 交互的唯一接口，动态地构建、执行请求和解析响应。
*   **核心方法**：
    *   **`getSourceConfig(sourceType, [sourceId])`**:
        *   **功能**：根据 `sourceType` 和可选的 `sourceId`，从 `external_data_sources` 集合中查找并返回**一个**活跃的数据源配置。
        *   **逻辑**：优先使用 `sourceId` 进行精确查找；如果未指定 `sourceId`，则查找所有 `is_active` 且 `source_type` 匹配的数据源，并返回 `priority` 最高的那个。加载 `api_key_name` 对应的实际 API Key。
        *   **设计模式**：**策略模式 (Strategy Pattern)** 的一部分，根据 `sourceType` 决定获取哪种配置策略。
    *   **`getAllActiveSourcesOfType(sourceType)`**:
        *   **功能**：返回所有 `is_active` 且 `source_type` 匹配的数据源配置数组，并已加载其 API Key。
        *   **逻辑**：遍历 `external_data_sources` 集合，筛选出符合条件的活跃数据源，加载其 API Key，并按优先级排序。
        *   **设计模式**：**策略模式 (Strategy Pattern)** 的一部分，返回所有可用的策略。
    *   **`fetchExternalData(sourceConfig, endpointKey, dynamicParams, [extraOptions])`**:
        *   **功能**：执行实际的 HTTP 请求，完全根据 `sourceConfig` 中的元数据动态构建请求（URL、方法、头、体）和解析响应。
        *   **参数**：
            *   `sourceConfig` (object): 由 `getSourceConfig` 或 `getAllActiveSourcesOfType` 返回的完整数据源配置对象。
            *   `endpointKey` (string): `sourceConfig.endpoint_paths` 中要使用的端点键名。
            *   `dynamicParams` (object): 动态变化的请求参数。
            *   `extraOptions` (object, optional): 额外的 `UrlFetchApp` 选项，用于覆盖 `sourceConfig` 中的默认设置。
        *   **内部逻辑**：
            1.  **URL 构建**：结合 `base_url`、`endpoint_paths[endpointKey]`、`fixed_query_params` 和 `dynamicParams`（如果是 GET 请求）。
            2.  **方法设置**：根据 `request_method` 设置 `UrlFetchApp.method`。
            3.  **请求头组装**：合并 `request_headers` 和 `extraOptions.headers`，并根据 `auth_method`、`api_key_header_name`、`apiKey` 动态添加认证头部。
            4.  **请求体准备**：根据 `payload_type` 和 `dynamicParams` 格式化 `UrlFetchApp.payload` 和 `contentType`。
            5.  **执行请求**：调用 `UrlFetchApp.fetch(finalUrl, options)`。
            6.  **响应解析**：根据 `response_type` (`json`, `xml`, `text`) 解析 `responseText`。
            7.  **错误处理**：统一捕获 HTTP 错误和解析错误。
        *   **设计模式**：
            *   **门面模式 (Facade Pattern)**：为复杂的 `UrlFetchApp` 调用和各种 API 协议提供一个简化的接口。
            *   **策略模式 (Strategy Pattern)**：`fetchExternalData` 的内部逻辑根据 `sourceConfig` 中定义的 `request_method`, `payload_type`, `response_type`, `auth_method` 等字段动态选择执行策略。
            *   **适配器模式 (Adapter Pattern)**：`DataConnector` 充当了通用业务逻辑（客户端）和各种异构外部 API（不兼容接口）之间的适配器。

##### **4.3. 工作流与业务逻辑层 (`backend/svc.Workflows.gs` 及其他服务)**

*   **职责**：专注于业务逻辑，不再关心数据获取的底层实现。
*   **交互方式**：
    1.  通过 `DataConnector.getAllActiveSourcesOfType(sourceType)` 获取所有符合条件的外部数据源配置。
    2.  遍历这些 `sourceConfig` 对象。
    3.  对于每个 `sourceConfig`，准备其特有的 `dynamicParams` 和 `extraOptions`。
    4.  调用 `DataConnector.fetchExternalData(sourceConfig, endpointKey, dynamicParams, extraOptions)`。
    5.  接收 `DataConnector` 返回的已解析数据（JSON 对象或 XML 字符串）。
    6.  根据 `sourceConfig.source_id` 或 `sourceConfig.response_type` 对数据进行**业务层面的适配和映射**，将其转换为系统内部统一的数据模型（例如 `RAW_ACADEMIC_PAPERS` 的格式）。

*   **设计模式**：**策略模式 (Strategy Pattern)**：工作流函数（Context）根据不同的 `sourceConfig.source_id`（具体策略的标识）来执行不同的数据解析和业务逻辑分支。

##### **4.4. 系统管理界面 (System Administration UI)**

*   **职责**：提供用户友好的界面，用于管理 `external_data_sources` 集合。
*   **实现要点**：
    *   在“系统”页面的“数据源管理”子 Tab 中，新增一个“外部数据源”的子 Tab。
    *   该 Tab 将动态渲染一个表格，展示 `external_data_sources` 集合中的所有条目。
    *   提供“新增”、“编辑”、“删除”按钮。
    *   “新增/编辑”操作将触发一个模态框，模态框中的表单字段将根据 `SystemAdminService.getAllRegistryMetaData()` 返回的 `EXTERNAL_DATA_SOURCES` 字段定义动态生成。
    *   **特殊处理**：`endpoint_paths`, `request_headers`, `fixed_query_params` 等 JSON 对象字段，在前端使用 `textarea` 显示，并进行 JSON 格式的输入/输出转换和校验。

---

**五、**开发设计模式总结**

本方案主要采用了以下设计模式：

1.  **配置即数据 (Configuration as Data)**：
    *   **描述**：将应用程序的行为（特别是与外部系统集成相关的行为）从代码中提取出来，作为数据存储。
    *   **应用**：`external_data_sources` Firestore 集合是这一模式的直接体现，所有外部 API 的调用细节都以数据形式存在。
    *   **优势**：极大地提高了系统的灵活性和可维护性，无需代码修改即可适应外部变化。

2.  **注册表模式 (Registry Pattern)**：
    *   **描述**：提供一个中央存储库，用于注册和查找系统中的各种可配置对象。
    *   **应用**：`external_data_sources` Firestore 集合作为所有外部数据源的中央注册表，`DataConnector` 通过它来查找和获取数据源配置。
    *   **优势**：集中管理，便于发现和动态加载。

3.  **门面模式 (Facade Pattern)**：
    *   **描述**：为子系统提供一个统一的接口，使得子系统更容易使用。
    *   **应用**：`DataConnector.fetchExternalData()` 方法为 `UrlFetchApp` 的复杂调用和各种 API 协议的差异提供了一个简化的、统一的接口。业务逻辑层（Workflows）无需了解底层 HTTP 请求构建和响应解析的复杂性。
    *   **优势**：降低了业务逻辑层与外部 API 集成的复杂性，提高了代码的可读性和可维护性。

4.  **策略模式 (Strategy Pattern)**：
    *   **描述**：定义一系列算法，将每一个算法封装起来，并使它们可以互换。
    *   **应用**：
        *   在 `DataConnector.fetchExternalData()` 内部，根据 `sourceConfig` 中的 `request_method`, `payload_type`, `response_type`, `auth_method` 等字段，动态选择并执行不同的请求构建和响应解析“策略”。
        *   在工作流层，当遍历 `getAllActiveSourcesOfType` 返回的多个数据源时，工作流会根据每个 `sourceConfig.source_id` 采取不同的业务数据适配“策略”。
    *   **优势**：实现了行为的动态切换，使得系统能够适应各种异构的外部 API 协议。

5.  **适配器模式 (Adapter Pattern)**：
    *   **描述**：将一个类的接口转换成客户希望的另一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
    *   **应用**：`DataConnector` 充当了通用业务逻辑层（客户端）和各种异构外部 API（不兼容接口）之间的适配器。它将外部 API 的原始接口“适配”成业务逻辑层期望的统一数据获取接口。
    *   **优势**：促进了不同接口的协同工作，提高了系统的互操作性。

---

**六、**开发实施步骤（高层）**

1.  **更新 `Config.gs`**：添加 `EXTERNAL_DATA_SOURCES` 集合名称。
2.  **创建 `external_data_sources` Firestore 集合**：手动或通过迁移脚本创建初始文档，包含 arXiv、NewsAPI、OpenAI 等现有数据源的详细配置。
3.  **创建/重构 `backend/DataConnector.gs`**：实现 `getSourceConfig`、`getAllActiveSourcesOfType` 和 `fetchExternalData` 方法，使其具备协议适配能力。
4.  **更新 `backend/svc.SystemAdminService.gs`**：
    *   在 `_registryMap` 中添加 `EXTERNAL_DATA_SOURCES` 的完整字段定义。
    *   确保其通用的 CRUD 方法能够处理 `external_data_sources` 集合。
5.  **更新 `backend/svc.Workflows.gs`** (及其他需要外部数据的服务)：
    *   修改 WF1-WF6 等工作流，以及 `_callAIForScoring`, `_callAIForTextGeneration`, `_callAIForEmbedding`, `_generateChartImage` 等辅助函数，使其通过 `DataConnector` 获取数据。
    *   在工作流内部，根据 `DataConnector` 返回的数据源 ID 或类型，编写业务层面的数据适配逻辑。
6.  **开发前端 UI**：
    *   在 `System` 页面的“数据源管理”下，新增“外部数据源”子 Tab。
    *   动态生成列表和模态框表单，支持所有 `external_data_sources` 字段的输入和展示，特别是 `textarea` 类型的 JSON 字段的转换和校验。
7.  **全面测试**：对每个数据源、每个工作流进行端到端的测试，确保数据获取、处理和存储的正确性。

---

这个详细的设计方案和图示，应该能清晰地描绘出“自适应外部数据源”系统的工作方式，以及我们如何通过数据化配置和设计模式来达成高度灵活和可扩展的目标。


太棒了，Jason！“实施”和“确保功能如常”是任何复杂系统迭代的生命线。我们将以安全、可验证的方式逐步进行。

由于涉及到核心的连接层重构，我们将采取**“自底向上”**的实施策略：
1.  **准备阶段：** 备份代码，设置好 Firestore 初始数据和 Script Properties。
2.  **核心服务开发与测试：** 先开发并彻底测试 `DataConnector`，确保其独立运行稳定。
3.  **集成测试：** 将 `DataConnector` 集成到工作流中，并进行功能验证。
4.  **管理界面开发：** 最后开发前端管理界面。

---

### **《自适应外部数据源系统实施方案与测试》**

**第一阶段：准备与核心服务开发**

**1.1. 代码备份**

*   **操作：** 在 Google Apps Script 项目中，点击 `项目概览` -> `部署` -> `管理部署` -> `编辑`，然后创建一个新的部署版本，或者直接下载项目（文件 -> 下载 -> JavaScript 文件）。
*   **重要性：** 这是最关键的一步，确保在出现任何问题时都能回滚到工作状态。

**1.2. 更新 `Config.gs`**

*   **操作：** 在 `Config.gs` 文件中，新增 `EXTERNAL_DATA_SOURCES` 集合的定义。
*   **代码：**

    ```javascript
    // 文件名: Config.gs (修改后)

    const CONFIG = {
      // ... 现有配置 ...

      FIRESTORE_COLLECTIONS: {
        // ... 现有集合 ...
        EXTERNAL_DATA_SOURCES: 'external_data_sources', // 新增：外部数据源注册表
        // ... 其他现有集合 ...
      },

      // ... 其他配置 ...
    };
    ```

**1.3. 在 Firestore 中创建 `external_data_sources` 集合并填充初始数据**

*   **操作：**
    1.  登录 Google Cloud Console，进入您的 Firestore 数据库。
    2.  创建一个名为 `external_data_sources` 的新集合。
    3.  **手动添加以下文档。** 这些文档是 `DataConnector` 正常工作的基础。请务必核对 `source_id`、`source_type`、`base_url`、`endpoint_paths`、`request_method`、`payload_type`、`response_type`、`auth_method`、`api_key_name`、`api_key_header_name`、`fixed_query_params` 等字段，确保与您当前工作流中使用的外部 API 匹配。

    **文档 1: arXiv 学术论文 API**
    *   `source_id`: `ARXIV_API`
    *   `display_name`: `arXiv 学术论文 API`
    *   `source_type`: `academic_paper_source`
    *   `base_url`: `http://export.arxiv.org`
    *   `endpoint_paths`: `{"query": "/api/query"}`
    *   `request_method`: `GET`
    *   `payload_type`: `none`
    *   `response_type`: `xml`
    *   `auth_method`: `none`
    *   `api_key_name`: `null`
    *   `api_key_header_name`: `null`
    *   `api_key_query_param_name`: `null`
    *   `request_headers`: `{"User-Agent": "DeepdiveEngine/1.0 (AppsScript)"}`
    *   `fixed_query_params`: `{"sortBy": "submittedDate", "sortOrder": "descending"}`
    *   `is_active`: `true`
    *   `priority`: `100`
    *   `notes`: `主要用于获取物理、数学、计算机科学等领域的预印本论文。`
    *   `created_timestamp`: `(当前时间戳)`
    *   `last_updated_timestamp`: `(当前时间戳)`

    **文档 2: NewsAPI 全球新闻数据**
    *   `source_id`: `NEWSAPI_ORG`
    *   `display_name`: `NewsAPI 全球新闻数据`
    *   `source_type`: `news_source`
    *   `base_url`: `https://newsapi.org`
    *   `endpoint_paths`: `{"everything": "/v2/everything", "top_headlines": "/v2/top-headlines"}`
    *   `request_method`: `GET`
    *   `payload_type`: `none`
    *   `response_type`: `json`
    *   `auth_method`: `header_key`
    *   `api_key_name`: `NEWS_API_KEY`
    *   `api_key_header_name`: `X-Api-Key`
    *   `api_key_query_param_name`: `null`
    *   `request_headers`: `{"User-Agent": "DeepdiveEngine/1.0 (AppsScript)"}`
    *   `fixed_query_params`: `{"language": "en"}`
    *   `is_active`: `true`
    *   `priority`: `90`
    *   `rate_limit_per_minute`: `10`
    *   `notes`: `提供全球主流媒体新闻数据。`
    *   `created_timestamp`: `(当前时间戳)`
    *   `last_updated_timestamp`: `(当前时间戳)`

    **文档 3: OpenAI LLM 服务**
    *   `source_id`: `OPENAI_API`
    *   `display_name`: `OpenAI LLM 服务`
    *   `source_type`: `llm_service`
    *   `base_url`: `https://api.openai.com`
    *   `endpoint_paths`: `{"chat_completions": "/v1/chat/completions", "embeddings": "/v1/embeddings"}`
    *   `request_method`: `POST`
    *   `payload_type`: `json`
    *   `response_type`: `json`
    *   `auth_method`: `bearer_token`
    *   `api_key_name`: `OPENAI_API_KEY`
    *   `api_key_header_name`: `Authorization`
    *   `api_key_query_param_name`: `null`
    *   `request_headers`: `{"Content-Type": "application/json", "User-Agent": "DeepdiveEngine/1.0 (AppsScript)"}`
    *   `fixed_query_params`: `null`
    *   `is_active`: `true`
    *   `priority`: `120`
    *   `rate_limit_per_minute`: `60`
    *   `notes`: `用于文本生成、评分和嵌入。`
    *   `created_timestamp`: `(当前时间戳)`
    *   `last_updated_timestamp`: `(当前时间戳)`

**1.4. 设置 Script Properties (API Keys)**

*   **操作：** 在 Apps Script 项目中，点击 `项目设置` -> `脚本属性`，确保以下键值对已正确设置。
*   **键值对：**
    *   `NEWS_API_KEY` : `您的 NewsAPI.org 密钥`
    *   `OPENAI_API_KEY`: `您的 OpenAI API 密钥`
    *   `CLOUDINARY_CLOUD_NAME`: `您的 Cloudinary Cloud Name`
    *   `CLOUDINARY_API_KEY`: `您的 Cloudinary API Key`
    *   `CLOUDINARY_API_SECRET`: `您的 Cloudinary API Secret`
    *   `GITHUB_TOKEN`: `您的 GitHub Token`
    *   `GITHUB_OWNER`: `您的 GitHub 用户名/组织名`
    *   `GITHUB_REPO`: `您的 GitHub 仓库名`

**1.5. 新增 `backend/DataConnector.gs`**

*   **操作：** 在 `backend` 目录下创建新文件 `DataConnector.gs`，并粘贴以下代码。
*   **代码：**

    ```javascript
    // 文件名: backend/DataConnector.gs

    const DataConnector = {
      _sourceCache: {}, // 内部缓存，避免频繁查询 Firestore

      /**
       * 清除缓存（例如在配置更新后调用）
       */
      clearCache: function() {
        this._sourceCache = {};
        Logger.log("[DataConnector] Source cache cleared.");
      },

      /**
       * 获取单个数据源配置。
       * 如果指定 sourceId，则精确查找；否则查找指定类型中优先级最高的活跃数据源。
       * @param {string} sourceType - 期望的数据源类型 (e.g., 'academic_paper_source', 'news_source')
       * @param {string} [sourceId=null] - 可选：指定特定的数据源ID
       * @returns {object} 数据源配置对象，包含 base_url, endpoint_paths, apiKey 等
       * @throws {Error} 如果未找到活跃数据源或API Key未配置
       */
      getSourceConfig: function(sourceType, sourceId = null) {
        const cacheKey = sourceId ? `${sourceType}_${sourceId}` : `${sourceType}_single_priority`;
        if (this._sourceCache[cacheKey]) {
          Logger.log(`[DataConnector] Returning single source '${cacheKey}' from cache.`);
          return this._sourceCache[cacheKey];
        }

        const allSources = DataService.getDataAsObjects(CONFIG.FIRESTORE_COLLECTIONS.EXTERNAL_DATA_SOURCES);
        if (!allSources || allSources.length === 0) {
          throw new Error(`未在 Firestore 中找到任何外部数据源配置。请检查 '${CONFIG.FIRESTORE_COLLECTIONS.EXTERNAL_DATA_SOURCES}' 集合。`);
        }

        let targetSource = null;
        if (sourceId) {
          targetSource = allSources.find(s => s.is_active && s.source_id === sourceId);
        } else {
          const activeSources = allSources.filter(s => s.is_active && s.source_type === sourceType);
          if (activeSources.length === 0) {
            throw new Error(`未找到类型为 '${sourceType}' 的活跃外部数据源。`);
          }
          activeSources.sort((a, b) => (b.priority || 0) - (a.priority || 0));
          targetSource = activeSources[0];
        }

        if (!targetSource) {
          throw new Error(`未找到指定ID '${sourceId}' 或类型 '${sourceType}' 的活跃外部数据源。`);
        }

        // 获取 API Key (如果需要)
        if (targetSource.api_key_name) {
          const apiKey = PropertiesService.getScriptProperties().getProperty(targetSource.api_key_name);
          if (!apiKey) {
            throw new Error(`外部数据源 '${targetSource.display_name}' (ID: ${targetSource.source_id}) 的 API Key 未在脚本属性中配置 (键名: ${targetSource.api_key_name})。`);
          }
          targetSource.apiKey = apiKey;
        }

        this._sourceCache[cacheKey] = targetSource; // 缓存结果
        return targetSource;
      },

      /**
       * 获取所有活跃的、指定类型的数据源配置。
       * @param {string} sourceType - 期望的数据源类型
       * @returns {Array<object>} 所有符合条件的活跃数据源配置对象数组
       */
      getAllActiveSourcesOfType: function(sourceType) {
        const cacheKey = `${sourceType}_all_active`;
        if (this._sourceCache[cacheKey]) {
          Logger.log(`[DataConnector] Returning all active sources for '${sourceType}' from cache.`);
          return this._sourceCache[cacheKey];
        }

        const allSources = DataService.getDataAsObjects(CONFIG.FIRESTORE_COLLECTIONS.EXTERNAL_DATA_SOURCES);
        if (!allSources || allSources.length === 0) {
          Logger.log(`[DataConnector] No external data source configurations found in Firestore.`);
          return [];
        }

        const activeSources = allSources.filter(s => s.is_active && s.source_type === sourceType);
        if (activeSources.length === 0) {
          Logger.log(`[DataConnector] No active external data sources found for type '${sourceType}'.`);
          return [];
        }

        // 为每个源获取 API Key
        const sourcesWithKeys = activeSources.map(source => {
          if (source.api_key_name) {
            const apiKey = PropertiesService.getScriptProperties().getProperty(source.api_key_name);
            if (!apiKey) {
              Logger.log(`[DataConnector] WARNING: API Key for source '${source.display_name}' (ID: ${source.source_id}) not configured. Skipping this source.`);
              return null; // 过滤掉没有配置 Key 的源
            }
            return { ...source, apiKey: apiKey };
          }
          return source;
        }).filter(s => s !== null); // 过滤掉因为 Key 缺失而返回 null 的源

        sourcesWithKeys.sort((a, b) => (b.priority || 0) - (a.priority || 0)); // 仍然按优先级排序

        this._sourceCache[cacheKey] = sourcesWithKeys; // 缓存结果
        return sourcesWithKeys;
      },

      /**
       * 执行对外部数据源的 API 请求 - 能够自适应多种请求方式。
       * @param {object} sourceConfig - 完整的数据源配置对象 (由 getSourceConfig 或 getAllActiveSourcesOfType 返回)
       * @param {string} endpointKey - 数据源配置中 endpoint_paths 的键名 (e.g., 'query', 'everything', 'chat_completions')
       * @param {object} dynamicParams - 动态参数对象，这些参数会根据 request_method 和 payload_type 决定是放在 URL 还是 Request Body
       * @param {object} [extraOptions={}] - 额外的 UrlFetchApp 请求选项，会覆盖 sourceConfig 中的默认设置
       * @returns {object|string} 解析后的 JSON/XML 对象或原始文本
       * @throws {Error} 如果 API 请求失败
       */
      fetchExternalData: function(sourceConfig, endpointKey, dynamicParams, extraOptions = {}) {
        if (!sourceConfig || !sourceConfig.base_url || !sourceConfig.endpoint_paths || !sourceConfig.endpoint_paths[endpointKey]) {
            throw new Error(`无效的数据源配置或端点键 '${endpointKey}'。`);
        }

        const fullUrlPath = `${sourceConfig.base_url}${sourceConfig.endpoint_paths[endpointKey]}`;
        let finalUrl = fullUrlPath;
        const options = { muteHttpExceptions: true };

        // 合并固定的和动态的查询参数
        const allQueryParams = {
          ...(sourceConfig.fixed_query_params || {}),
          ...(sourceConfig.request_method === 'GET' ? dynamicParams : {}) // GET 请求的动态参数作为查询参数
        };

        // 构建 URL 查询字符串
        const queryString = Object.keys(allQueryParams)
          .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(allQueryParams[key])}`)
          .join('&');

        if (queryString) {
          finalUrl += `?${queryString}`;
        }

        // 设置请求方法
        options.method = (sourceConfig.request_method || 'GET').toLowerCase();

        // 合并固定的和额外的请求头
        options.headers = {
          ...(sourceConfig.request_headers || {}),
          ...(extraOptions.headers || {}) // 额外选项中的 headers 优先级更高
        };
        // 确保 User-Agent 存在，一些API强制要求
        if (!options.headers['User-Agent']) {
          options.headers['User-Agent'] = 'DeepdiveEngine/1.0 (Google Apps Script)';
        }

        // 处理认证
        if (sourceConfig.auth_method === 'header_key' && sourceConfig.api_key_header_name && sourceConfig.apiKey) {
          options.headers[sourceConfig.api_key_header_name] = sourceConfig.apiKey;
        } else if (sourceConfig.auth_method === 'bearer_token' && sourceConfig.api_key_header_name && sourceConfig.apiKey) {
          options.headers[sourceConfig.api_key_header_name] = `Bearer ${sourceConfig.apiKey}`;
        } else if (sourceConfig.auth_method === 'query_param_key' && sourceConfig.api_key_query_param_name && sourceConfig.apiKey) {
          const separator = finalUrl.includes('?') ? '&' : '?';
          finalUrl += `${separator}${encodeURIComponent(sourceConfig.api_key_query_param_name)}=${encodeURIComponent(sourceConfig.apiKey)}`;
        } else if (sourceConfig.auth_method === 'basic_auth' && sourceConfig.apiKey) {
          options.headers['Authorization'] = `Basic ${Utilities.base64Encode(sourceConfig.apiKey)}`;
        }

        // 处理请求体 (Payload) - 仅适用于非 GET 请求
        if (options.method !== 'get' && dynamicParams) {
          switch (sourceConfig.payload_type) {
            case 'json':
              options.contentType = 'application/json';
              options.payload = JSON.stringify(dynamicParams);
              break;
            case 'form_urlencoded':
              options.contentType = 'application/x-www-form-urlencoded';
              options.payload = Object.keys(dynamicParams)
                .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(dynamicParams[key])}`)
                .join('&');
              break;
            case 'xml':
              options.contentType = 'application/xml';
              options.payload = dynamicParams; // 假设 dynamicParams 直接就是 XML 字符串
              break;
            case 'none': // 明确表示没有 payload
              delete options.payload;
              delete options.contentType;
              break;
            default:
              Logger.log(`[DataConnector] WARNING: 未知 payload_type: ${sourceConfig.payload_type}，跳过 payload 处理。`);
              break;
          }
        }

        // 合并额外的 UrlFetchApp 选项 (例如 deadline, followRedirects 等)
        Object.assign(options, extraOptions);

        Logger.log(`[DataConnector] Fetching from ${sourceConfig.display_name} (URL: ${finalUrl.substring(0, 200)}..., Method: ${options.method}, PayloadType: ${sourceConfig.payload_type || 'none'})...`);
        // Logger.log(`[DataConnector] Request Options: ${JSON.stringify(options)}`); // 调试时可以打开

        const response = UrlFetchApp.fetch(finalUrl, options);
        const responseCode = response.getResponseCode();
        const responseText = response.getContentText();

        if (responseCode >= 200 && responseCode < 300) {
          switch (sourceConfig.response_type) {
            case 'json':
              try {
                return JSON.parse(responseText);
              } catch (e) {
                throw new Error(`响应解析失败 (JSON): ${e.message}. 原始响应: ${responseText.substring(0, 200)}...`);
              }
            case 'xml':
              return responseText; // 返回原始 XML 文本
            case 'text':
              return responseText;
            default:
              Logger.log(`[DataConnector] WARNING: 未知 response_type: ${sourceConfig.response_type}，返回原始文本。`);
              return responseText;
          }
        } else {
          throw new Error(`API 请求失败 (${sourceConfig.display_name} - ${responseCode}): ${responseText.substring(0, 200)}...`);
        }
      }
    };
    ```

**1.6. `backend/utils.gs` (添加 `DateUtils` 辅助函数)**

*   **操作：** 确保 `backend/utils.gs` 文件中包含 `DateUtils` 对象，因为 `SystemAdminService` 和其他地方会用到。
*   **代码：**

    ```javascript
    // 文件名: backend/utils.gs

    const DateUtils = {
      formatDate: function(dateValue, includeTime = false, formatString = null) {
        if (!dateValue) return 'N/A';
        let dateObj;
        if (dateValue instanceof Date) {
          dateObj = dateValue;
        } else {
          dateObj = new Date(dateValue);
        }
        if (isNaN(dateObj.getTime())) {
          return String(dateValue);
        }
        const format = formatString || (includeTime ? 'yyyy-MM-dd HH:mm:ss' : 'yyyy-MM-dd');
        return Utilities.formatDate(dateObj, Session.getScriptTimeZone(), format);
      },
      parseDate: function(dateString) {
        if (!dateString) return null;
        if (dateString instanceof Date) return dateString;
        const dateObj = new Date(dateString);
        if (isNaN(dateObj.getTime())) {
          const parts = String(dateString).match(/^(\d{4})-(\\d{2})-(\\d{2})$/);
          if (parts) {
            const utcDateObj = new Date(`${parts[1]}-${parts[2]}-${parts[3]}T00:00:00Z`);
            if (!isNaN(utcDateObj.getTime())) {
              return utcDateObj;
            }
          }
          return null;
        }
        return dateObj;
      }
    };
    ```

**1.7. `backend/FirestoreService.gs` (添加 `autoId` 方法)**

*   **操作：** 确保 `backend/FirestoreService.gs` 文件中包含 `autoId` 方法，`SystemAdminService` 在新增条目时会用到。
*   **代码：**

    ```javascript
    // 文件名: backend/FirestoreService.gs

    const FirestoreService = {
      // ... 现有属性和方法 ...

      autoId: function() {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let autoId = '';
        for (let i = 0; i < 20; i++) {
          autoId += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return autoId;
      },

      // ... 剩余方法 ...
    };
    ```

**1.8. 测试 `DataConnector` (独立单元测试)**

在 `backend` 目录下创建一个新的 `test.DataConnector.gs` 文件，用于独立测试 `DataConnector` 的功能。

*   **操作：** 创建文件 `backend/test.DataConnector.gs`，并粘贴以下测试代码。
*   **运行：** 在 Apps Script 编辑器中，从函数列表中选择 `test_DataConnector_All()` 并运行。查看 `执行日志`。

```javascript
// 文件名: backend/test.DataConnector.gs

function test_DataConnector_All() {
  console.log("=====================================================");
  console.log("--- Starting DataConnector Unit Tests ---");
  console.log("=====================================================");

  try {
    // 确保 DataConnector 缓存是空的，每次测试都从 Firestore 重新读取
    DataConnector.clearCache();

    test_DataConnector_GetSourceConfig_Single();
    DataConnector.clearCache(); // 每次测试后清空缓存
    test_DataConnector_GetAllActiveSourcesOfType();
    DataConnector.clearCache();
    test_DataConnector_FetchExternalData_Arxiv();
    DataConnector.clearCache();
    test_DataConnector_FetchExternalData_NewsAPI();
    DataConnector.clearCache();
    test_DataConnector_FetchExternalData_OpenAI_ChatCompletions();
    DataConnector.clearCache();
    test_DataConnector_FetchExternalData_OpenAI_Embeddings();

    console.log("\n=====================================================");
    console.log("--- All DataConnector Tests Completed Successfully ---");
    console.log("=====================================================");

  } catch (e) {
    console.error("\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
    console.error(`!!! DataConnector Unit Tests FAILED: ${e.message} !!!`);
    console.error(`Stack: ${e.stack}`);
    console.error("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
    throw e; // 重新抛出错误，以便 Apps Script 标记执行失败
  }
}


function test_DataConnector_GetSourceConfig_Single() {
  console.log("\n--- Test: getSourceConfig (Single Source) ---");
  try {
    const arxivConfig = DataConnector.getSourceConfig('academic_paper_source', 'ARXIV_API');
    console.log(`✅ Fetched arXiv config: ${arxivConfig.display_name}`);
    console.assert(arxivConfig.base_url === 'http://export.arxiv.org', 'Arxiv base_url mismatch');
    console.assert(arxivConfig.endpoint_paths.query === '/api/query', 'Arxiv endpoint_paths mismatch');

    const newsApiConfig = DataConnector.getSourceConfig('news_source', 'NEWSAPI_ORG');
    console.log(`✅ Fetched NewsAPI config: ${newsApiConfig.display_name}`);
    console.assert(newsApiConfig.base_url === 'https://newsapi.org', 'NewsAPI base_url mismatch');
    console.assert(newsApiConfig.apiKey && newsApiConfig.apiKey.length > 0, 'NewsAPI API Key missing');

    const openaiConfig = DataConnector.getSourceConfig('llm_service', 'OPENAI_API');
    console.log(`✅ Fetched OpenAI config: ${openaiConfig.display_name}`);
    console.assert(openaiConfig.base_url === 'https://api.openai.com', 'OpenAI base_url mismatch');
    console.assert(openaiConfig.apiKey && openaiConfig.apiKey.startsWith('sk-'), 'OpenAI API Key missing or malformed');

    console.log("--- getSourceConfig (Single Source) tests passed. ---");
  } catch (e) {
    console.error(`❌ getSourceConfig (Single Source) test failed: ${e.message}`);
    throw e;
  }
}

function test_DataConnector_GetAllActiveSourcesOfType() {
  console.log("\n--- Test: getAllActiveSourcesOfType ---");
  try {
    const academicSources = DataConnector.getAllActiveSourcesOfType('academic_paper_source');
    console.log(`✅ Found ${academicSources.length} active academic paper sources.`);
    console.assert(academicSources.length >= 1, 'Expected at least one academic source.');
    const arxiv = academicSources.find(s => s.source_id === 'ARXIV_API');
    console.assert(arxiv !== undefined, 'ARXIV_API not found in active academic sources.');
    console.log("--- getAllActiveSourcesOfType tests passed. ---");
  } catch (e) {
    console.error(`❌ getAllActiveSourcesOfType test failed: ${e.message}`);
    throw e;
  }
}

function test_DataConnector_FetchExternalData_Arxiv() {
  console.log("\n--- Test: fetchExternalData (arXiv - XML Response) ---");
  try {
    const arxivConfig = DataConnector.getSourceConfig('academic_paper_source', 'ARXIV_API');
    const queryParams = { search_query: 'all:quantum computing', max_results: 1 };
    const responseXml = DataConnector.fetchExternalData(arxivConfig, 'query', queryParams);

    console.log(`✅ Received response from arXiv. Length: ${responseXml.length} chars.`);
    console.assert(typeof responseXml === 'string', 'Arxiv response should be string (XML)');
    console.assert(responseXml.includes('<feed'), 'Arxiv response should contain XML feed tag');
    
    // 尝试解析 XML，确认其有效性
    const document = XmlService.parse(responseXml);
    const root = document.getRootElement();
    const atomNs = XmlService.getNamespace('http://www.w3.org/2005/Atom');
    const entries = root.getChildren('entry', atomNs);
    console.assert(entries.length > 0, 'Arxiv XML should contain at least one entry');
    console.log(`  -> First entry title: ${entries[0].getChild('title', atomNs).getText().substring(0, 50)}...`);

    console.log("--- fetchExternalData (arXiv) tests passed. ---");
  } catch (e) {
    console.error(`❌ fetchExternalData (arXiv) test failed: ${e.message}`);
    throw e;
  }
}

function test_DataConnector_FetchExternalData_NewsAPI() {
  console.log("\n--- Test: fetchExternalData (NewsAPI - JSON Response, Header Auth) ---");
  try {
    const newsApiConfig = DataConnector.getSourceConfig('news_source', 'NEWSAPI_ORG');
    const queryParams = { q: 'artificial intelligence', pageSize: 1 };
    const responseJson = DataConnector.fetchExternalData(newsApiConfig, 'everything', queryParams);

    console.log(`✅ Received response from NewsAPI. Total results: ${responseJson.totalResults}.`);
    console.assert(typeof responseJson === 'object', 'NewsAPI response should be object (JSON)');
    console.assert(responseJson.articles && responseJson.articles.length > 0, 'NewsAPI response should contain articles');
    console.log(`  -> First article title: ${responseJson.articles[0].title.substring(0, 50)}...`);

    console.log("--- fetchExternalData (NewsAPI) tests passed. ---");
  } catch (e) {
    console.error(`❌ fetchExternalData (NewsAPI) test failed: ${e.message}`);
    throw e;
  }
}

function test_DataConnector_FetchExternalData_OpenAI_ChatCompletions() {
  console.log("\n--- Test: fetchExternalData (OpenAI Chat - POST JSON, Bearer Auth) ---");
  try {
    const openaiConfig = DataConnector.getSourceConfig('llm_service', 'OPENAI_API');
    const dynamicParams = {
      model: "gpt-3.5-turbo", // 使用一个便宜且快速的模型进行测试
      messages: [{ role: "user", content: "Hello, what is your name?" }],
      max_tokens: 20
    };
    const responseJson = DataConnector.fetchExternalData(openaiConfig, 'chat_completions', dynamicParams);

    console.log(`✅ Received response from OpenAI Chat. Choice: ${responseJson.choices[0].message.content.substring(0, 50)}...`);
    console.assert(typeof responseJson === 'object', 'OpenAI Chat response should be object (JSON)');
    console.assert(responseJson.choices && responseJson.choices.length > 0, 'OpenAI Chat response should contain choices');

    console.log("--- fetchExternalData (OpenAI Chat) tests passed. ---");
  } catch (e) {
    console.error(`❌ fetchExternalData (OpenAI Chat) test failed: ${e.message}`);
    throw e;
  }
}

function test_DataConnector_FetchExternalData_OpenAI_Embeddings() {
  console.log("\n--- Test: fetchExternalData (OpenAI Embeddings - POST JSON, Bearer Auth) ---");
  try {
    const openaiConfig = DataConnector.getSourceConfig('llm_service', 'OPENAI_API');
    const dynamicParams = {
      model: "text-embedding-3-small",
      input: "This is a test sentence for embedding."
    };
    const responseJson = DataConnector.fetchExternalData(openaiConfig, 'embeddings', dynamicParams);

    console.log(`✅ Received response from OpenAI Embeddings. Data length: ${responseJson.data[0].embedding.length}.`);
    console.assert(typeof responseJson === 'object', 'OpenAI Embeddings response should be object (JSON)');
    console.assert(responseJson.data && responseJson.data.length > 0 && responseJson.data[0].embedding, 'OpenAI Embeddings response should contain embedding');
    console.assert(Array.isArray(responseJson.data[0].embedding), 'Embedding should be an array');

    console.log("--- fetchExternalData (OpenAI Embeddings) tests passed. ---");
  } catch (e) {
    console.error(`❌ fetchExternalData (OpenAI Embeddings) test failed: ${e.message}`);
    throw e;
  }
}
```

---

**第二阶段：工作流集成与验证**

**2.1. 修改 `backend/svc.Workflows.gs`**

*   **操作：** 替换 `WorkflowsService` 中所有硬编码的 `UrlFetchApp.fetch` 调用，改为通过 `DataConnector` 进行动态获取。
*   **代码：** (以下只提供部分示例，您需要将所有相关函数进行类似修改)

    ```javascript
    // 文件名: backend/svc.Workflows.gs (修改后，只展示部分关键改动)

    const WorkflowsService = {
      // ... 现有辅助函数 _bytesToHex, _logExecution 等 ...

      /**
       * ✅ 修改后的 WF1: 学术论文监控，支持多源并行获取
       */
      runWf1_AcademicPapers: function() {
        const wfName = 'WF1: 学术论文监控';
        const startTime = new Date();
        const executionId = `exec_wf1_${startTime.getTime()}`;
        let logMessages = [`[${new Date().toLocaleTimeString()}] ${wfName} (${executionId}) 开始执行...`];
        let successCount = 0, processedCount = 0, errorCount = 0, duplicateCount = 0;

        try {
          const techRegistry = DataService.getDataAsObjects('TECH_REGISTRY');
          const activeTechs = techRegistry.filter(t =>
            t.monitoring_status === 'active' && t.data_source_academic === true);
          logMessages.push(`发现 ${activeTechs.length} 个活跃的技术监控项。`);

          if (activeTechs.length === 0) {
            this._logExecution(wfName, executionId, startTime, 'completed', 0, 0, 0, "没有需要监控的活跃技术项。");
            return { success: true, message: "没有需要监控的活跃技术项。", log: logMessages.join('\n') };
          }
          
          let allNewPaperObjects = [];
          const existingHashes = new Set(
              (DataService.getDataAsObjects('RAW_ACADEMIC_PAPERS') || [])
              .map(item => item.duplicate_check_hash)
              .filter(Boolean)
          );
          logMessages.push(`  -> 现有 ${existingHashes.size} 条历史记录用于去重检查。`);

          // ✅ 核心改变：获取所有活跃的学术数据源
          const academicSources = DataConnector.getAllActiveSourcesOfType('academic_paper_source');
          if (academicSources.length === 0) {
            this._logExecution(wfName, executionId, startTime, 'completed', 0, 0, 0, "没有配置活跃的学术数据源。");
            return { success: true, message: "没有配置活跃的学术数据源。", log: logMessages.join('\n') };
          }
          logMessages.push(`发现 ${academicSources.length} 个活跃的学术数据源: ${academicSources.map(s => s.display_name).join(', ')}`);

          for (const tech of activeTechs) {
            const searchTerms = (tech.academic_search_terms || "").split(',').map(s => s.trim()).filter(Boolean);
            if (searchTerms.length === 0) {
                logMessages.push(`警告: 技术 '${tech.tech_name}' 没有配置学术搜索词，跳过。`);
                continue;
            }

            for (const sourceConfig of academicSources) { // ✅ 遍历所有学术数据源
              for (const term of searchTerms) {
                logMessages.push(`正在从 ${sourceConfig.display_name} 为技术 '${tech.tech_name}' 搜索关键词: '${term}'...`);
                
                try {
                  let papersData = [];
                  if (sourceConfig.source_id === 'ARXIV_API') {
                    const queryParams = { search_query: `all:${term}`, max_results: 5 };
                    const responseXml = DataConnector.fetchExternalData(sourceConfig, 'query', queryParams);
                    // 解析 arXiv XML
                    const document = XmlService.parse(responseXml);
                    const root = document.getRootElement();
                    const atomNs = XmlService.getNamespace('http://www.w3.org/2005/Atom');
                    const entries = root.getChildren('entry', atomNs);

                    papersData = entries.map(entry => ({
                      url: entry.getChild('id', atomNs).getText(),
                      title: entry.getChild('title', atomNs).getText(),
                      summary: entry.getChild('summary', atomNs).getText(),
                      authors: entry.getChildren('author', atomNs).map(a => a.getChild('name', atomNs).getText()).join(', '),
                      published: new Date(entry.getChild('published', atomNs).getText())
                    }));

                  } else if (sourceConfig.source_id === 'PUBMED_API') {
                    // 这里需要根据您实际的 PubMed API 结构来编写解析逻辑
                    // 假设 PubMed 也返回 XML 或 JSON，并且您将其适配到统一的 papersData 结构
                    // 这是一个示例，您需要根据实际的 PubMed API 响应格式进行调整
                    const queryParamsSearch = {
                        term: term,
                        retmax: 5,
                        sort: 'pub date'
                        // api_key: sourceConfig.apiKey // 如果是 query_param_key，API key 会自动添加到 URL
                    };
                    const searchResponse = DataConnector.fetchExternalData(sourceConfig, 'search', queryParamsSearch);
                    // 假设 searchResponse 包含 ID 列表，然后需要调用 fetch 获取详情
                    // 这是一个简化的 mock，您需要实现实际的 PubMed 解析
                    if (searchResponse && searchResponse.esearchresult && searchResponse.esearchresult.idlist && searchResponse.esearchresult.idlist.length > 0) {
                        const ids = searchResponse.esearchresult.idlist;
                        // 假设可以直接获取详情，或者需要再次调用 fetch
                        papersData = ids.map(id => ({
                            url: `https://pubmed.ncbi.nlm.nih.gov/${id}/`,
                            title: `PubMed Paper for ${term} (ID: ${id})`,
                            summary: `Abstract from PubMed for ${term} (ID: ${id})`,
                            authors: 'PubMed Authors',
                            published: new Date()
                        }));
                    }
                  }
                  // ... 可以添加更多数据源的特定处理 ...

                  for (const paper of papersData) {
                    const duplicateHash = this._bytesToHex(Utilities.computeDigest(Utilities.DigestAlgorithm.MD5, paper.url));

                    if (existingHashes.has(duplicateHash)) {
                      logMessages.push(`  -> 发现重复论文，跳过: ${paper.title.substring(0,30)}... (Hash: ${duplicateHash})`);
                      duplicateCount++;
                      continue;
                    }

                    // AI 预处理部分保持不变
                    logMessages.push(`  -> 正在为论文 "${paper.title.substring(0,30)}..." 生成 AI 摘要/关键词/向量...`);
                    const aiPrompt = `请为以下论文生成一个不超过100字的精炼摘要，和3-5个最核心的技术关键词（以逗号分隔）。\n\n标题: ${paper.title}\n摘要: ${paper.summary}`;
                    const aiResponse = this._callAIForTextGeneration(aiPrompt);

                    let ai_summary = "";
                    let ai_keywords = "";
                    const lines = aiResponse ? aiResponse.split('\n') : [];
                    if (lines.length > 0) {
                        ai_summary = lines[0].trim();
                        if (lines.length > 1 && lines[1].toLowerCase().includes('关键词')) {
                            ai_keywords = lines[1].replace(/关键词[:：]/gi, '').trim();
                        } else if (lines.length > 1) {
                            ai_keywords = lines.find(line => line.toLowerCase().includes('关键词')) || lines[1];
                            ai_keywords = ai_keywords.replace(/关键词[:：]/gi, '').trim();
                        }
                    }
                    
                    const textForEmbedding = `${paper.title} ${ai_summary} ${ai_keywords}`;
                    const embeddingVector = this._callAIForEmbedding(textForEmbedding);

                    const paperDataObject = {
                        raw_id: `RAW_AP_${Utilities.formatDate(new Date(), 'UTC', 'yyyyMMddHHmmssSSS')}_${duplicateHash.substring(0, 6)}`,
                        id: `RAW_AP_${Utilities.formatDate(new Date(), 'UTC', 'yyyyMMddHHmmssSSS')}_${duplicateHash.substring(0, 6)}`,
                        source_type: 'academic_papers',
                        title: paper.title,
                        abstract: paper.summary,
                        authors: paper.authors,
                        publication_date: paper.published,
                        source_url: paper.url,
                        source_platform: sourceConfig.display_name, // 记录来自哪个具体源
                        innovation_score: 0,
                        tech_keywords: tech.tech_keywords,
                        ai_summary: ai_summary,
                        ai_keywords: ai_keywords,
                        embedding: embeddingVector,
                        processing_status: 'pending',
                        workflow_execution_id: executionId,
                        created_timestamp: new Date(),
                        last_update_timestamp: new Date(),
                        duplicate_check_hash: duplicateHash
                    };
                    allNewPaperObjects.push(paperDataObject);
                    successCount++;
                  }
                } catch (sourceError) {
                  logMessages.push(`警告: 从数据源 ${sourceConfig.display_name} 获取数据失败: ${sourceError.message}`);
                  errorCount++;
                }
              }
            }
          }
          
          if (allNewPaperObjects.length > 0) {
            DataService.batchUpsert('RAW_ACADEMIC_PAPERS', allNewPaperObjects, 'raw_id');
            logMessages.push(`成功写入 ${allNewPaperObjects.length} 条论文数据（含AI预处理）。`);
          }
          
          const finalMessage = `成功处理 ${activeTechs.length} 个技术项，从 ${academicSources.length} 个源发现 ${successCount} 篇论文（含AI预处理），跳过 ${duplicateCount} 条重复论文。`;
          this._logExecution(wfName, executionId, startTime, 'completed', processedCount, successCount, errorCount, finalMessage);
          return { success: true, message: finalMessage, log: logMessages.join('\n') };

        } catch (e) {
          const errorMessage = `严重错误: ${e.message}`;
          this._logExecution(wfName, executionId, startTime, 'failed', processedCount, successCount, errorCount + 1, errorMessage);
          return { success: false, message: errorMessage, log: logMessages.join('\n') };
        }
      },

      // --- WF2: 专利申请追踪 (示例修改) ---
      runWf2_PatentData: function() {
        const wfName = 'WF2: 专利申请追踪';
        const startTime = new Date();
        const executionId = `exec_wf2_${startTime.getTime()}`;
        let logMessages = [`[${new Date().toLocaleTimeString()}] ${wfName} (${executionId}) 开始执行...`];
        let successCount = 0, processedCount = 0, errorCount = 0, duplicateCount = 0;

        try {
          const techRegistry = DataService.getDataAsObjects('TECH_REGISTRY')
                                         .filter(t => t.monitoring_status === 'active' && t.data_source_patent === true);
          
          processedCount = techRegistry.length;
          logMessages.push(`发现 ${processedCount} 个需要监控专利的技术领域。`);

          if (processedCount === 0) {
            const msg = "没有需要监控专利的活跃技术领域。";
            this._logExecution(wfName, executionId, startTime, 'completed', 0, 0, 0, msg);
            return { success: true, message: msg, log: logMessages.join('\n') };
          }

          let allNewPatentObjects = [];
          const existingHashes = new Set(
              (DataService.getDataAsObjects('RAW_PATENT_DATA') || [])
              .map(item => item.duplicate_check_hash)
              .filter(Boolean)
          );
          logMessages.push(`  -> 现有 ${existingHashes.size} 条历史记录用于去重检查。`);

          // ✅ 动态获取所有活跃的专利数据源
          const patentSources = DataConnector.getAllActiveSourcesOfType('patent_data_source');
          if (patentSources.length === 0) {
            this._logExecution(wfName, executionId, startTime, 'completed', 0, 0, 0, "没有配置活跃的专利数据源。");
            return { success: true, message: "没有配置活跃的专利数据源。", log: logMessages.join('\n') };
          }
          logMessages.push(`发现 ${patentSources.length} 个活跃的专利数据源: ${patentSources.map(s => s.display_name).join(', ')}`);

          for (const tech of techRegistry) {
            const searchTerms = (tech.patent_search_terms || "").split(',').map(s => s.trim()).filter(Boolean);
            if (searchTerms.length === 0) {
                logMessages.push(`警告: 技术 '${tech.tech_name}' 没有配置专利搜索词，跳过。`);
                continue;
            }

            for (const sourceConfig of patentSources) { // ✅ 遍历所有专利数据源
              for (const term of searchTerms) {
                logMessages.push(`正在从 ${sourceConfig.display_name} 为技术 '${tech.tech_name}' 搜索专利: '${term}'...`);
                
                try {
                  let patentsData = [];
                  // ⚠️ 注意：这里需要根据您实际接入的专利 API 进行适配。
                  // 假设您有一个名为 "PATENT_API_MOCK" 的数据源，或者您可以集成真实的专利 API
                  if (sourceConfig.source_id === 'PATENT_API_MOCK') {
                    // 模拟专利API调用，实际需要替换为真实API
                    patentsData = [
                      { url: `https://mockpatent.com/1?q=${term}`, title: `Patent for ${term} AI`, abstract: `This patent describes an innovative method for ${term} based AI...`, patent_number: `US${Math.floor(Math.random()*1e8)}`, application_date: new Date(2025, 5, Math.floor(Math.random()*30)+1), inventors: 'John Doe' },
                      { url: `https://mockpatent.com/2?q=${term}`, title: `Another Patent on ${term} Robotics`, abstract: `This covers new robotic applications of ${term} technology...`, patent_number: `US${Math.floor(Math.random()*1e8)}`, application_date: new Date(2025, 4, Math.floor(Math.random()*30)+1), inventors: 'Jane Smith' },
                    ];
                  }
                  // ... 可以添加更多专利数据源的特定处理 ...

                  for (const patent of patentsData) {
                    const duplicateHash = this._bytesToHex(Utilities.computeDigest(Utilities.DigestAlgorithm.MD5, patent.url));
                    if (existingHashes.has(duplicateHash)) {
                        logMessages.push(`  -> 发现重复专利，跳过: ${patent.title.substring(0,30)}... (Hash: ${duplicateHash})`);
                        duplicateCount++;
                        continue;
                    }
                    
                    // AI 预处理部分保持不变
                    logMessages.push(`  -> 正在为专利 "${patent.title.substring(0,30)}..." 生成 AI 摘要/关键词/向量...`);
                    const aiPrompt = `请为以下专利生成一个不超过80字的精炼摘要，和3-5个最核心的技术关键词（以逗号分隔）。\n\n专利标题: ${patent.title}\n摘要: ${patent.abstract}`;
                    const aiResponse = this._callAIForTextGeneration(aiPrompt);

                    let ai_summary = "";
                    let ai_keywords = "";
                    const lines = aiResponse ? aiResponse.split('\n') : [];
                    if (lines.length > 0) {
                        ai_summary = lines[0].trim();
                        if (lines.length > 1 && lines[1].toLowerCase().includes('关键词')) {
                            ai_keywords = lines[1].replace(/关键词[:：]/gi, '').trim();
                        } else if (lines.length > 1) {
                            ai_keywords = lines.find(line => line.toLowerCase().includes('关键词')) || lines[1];
                            ai_keywords = ai_keywords.replace(/关键词[:：]/gi, '').trim();
                        }
                    }
                    
                    const textForEmbedding = `${patent.title} ${ai_summary} ${ai_keywords}`;
                    const embeddingVector = this._callAIForEmbedding(textForEmbedding);

                    const patentDataObject = {
                        raw_id: `RAW_PT_${Utilities.formatDate(new Date(), 'UTC', 'yyyyMMddHHmmssSSS')}_${duplicateHash.substring(0, 6)}`,
                        id: `RAW_PT_${Utilities.formatDate(new Date(), 'UTC', 'yyyyMMddHHmmssSSS')}_${duplicateHash.substring(0, 6)}`,
                        source_type: 'patent_data',
                        title: patent.title,
                        abstract: patent.abstract,
                        patent_number: patent.patent_number,
                        application_date: patent.application_date,
                        inventors: patent.inventors,
                        status: patent.status || 'unknown',
                        ai_summary: ai_summary,
                        ai_keywords: ai_keywords,
                        embedding: embeddingVector,
                        processing_status: 'pending',
                        workflow_execution_id: executionId,
                        created_timestamp: new Date(),
                        last_update_timestamp: new Date(),
                        duplicate_check_hash: duplicateHash
                    };
                    allNewPatentObjects.push(patentDataObject);
                    successCount++;
                  }
                } catch (sourceError) {
                  logMessages.push(`警告: 从数据源 ${sourceConfig.display_name} 获取数据失败: ${sourceError.message}`);
                  errorCount++;
                }
              }
            }
          }

          if (allNewPatentObjects.length > 0) {
            DataService.batchUpsert('RAW_PATENT_DATA', allNewPatentObjects, 'raw_id');
            logMessages.push(`成功写入 ${allNewPatentObjects.length} 条专利数据（含AI预处理）。`);
          }
          
          const finalMessage = `成功处理 ${processedCount} 个技术项，从 ${patentSources.length} 个源发现 ${successCount} 篇专利（含AI预处理），跳过 ${duplicateCount} 条重复专利。`;
          this._logExecution(wfName, executionId, startTime, 'completed', processedCount, successCount, errorCount, finalMessage);
          return { success: true, message: finalMessage, log: logMessages.join('\n') };

        } catch (e) {
          const errorMessage = `严重错误: ${e.message}`;
          this._logExecution(wfName, executionId, startTime, 'failed', processedCount, successCount, errorCount + 1, errorMessage);
          return { success: false, message: errorMessage, log: logMessages.join('\n') };
        }
      },

      // --- WF3: 开源项目监测 (示例修改) ---
      runWf3_OpenSource: function() {
        const wfName = 'WF3: 开源项目监测';
        const startTime = new Date();
        const executionId = `exec_wf3_${startTime.getTime()}`;
        let logMessages = [`[${new Date().toLocaleTimeString()}] ${wfName} (${executionId}) 开始执行...`];
        let successCount = 0, processedCount = 0, errorCount = 0, duplicateCount = 0;

        try {
          const techRegistry = DataService.getDataAsObjects('TECH_REGISTRY')
                                         .filter(t => t.monitoring_status === 'active' && t.data_source_opensource === true);
          processedCount = techRegistry.length;
          logMessages.push(`发现 ${processedCount} 个需要监控开源项目的技术领域。`);

          if (processedCount === 0) {
            const msg = "没有需要监控开源项目的活跃技术领域。";
            this._logExecution(wfName, executionId, startTime, 'completed', 0, 0, 0, msg);
            return { success: true, message: msg, log: logMessages.join('\n') };
          }

          let allNewProjectsObjects = [];
          const existingHashes = new Set(
              (DataService.getDataAsObjects('RAW_OPENSOURCE_DATA') || [])
              .map(item => item.duplicate_check_hash)
              .filter(Boolean)
          );
          logMessages.push(`  -> 现有 ${existingHashes.size} 条历史记录用于去重检查。`);

          // ✅ 动态获取所有活跃的开源数据源
          const opensourceSources = DataConnector.getAllActiveSourcesOfType('opensource_data_source');
          if (opensourceSources.length === 0) {
            this._logExecution(wfName, executionId, startTime, 'completed', 0, 0, 0, "没有配置活跃的开源数据源。");
            return { success: true, message: "没有配置活跃的开源数据源。", log: logMessages.join('\n') };
          }
          logMessages.push(`发现 ${opensourceSources.length} 个活跃的开源数据源: ${opensourceSources.map(s => s.display_name).join(', ')}`);

          for (const tech of techRegistry) {
            const searchTerms = (tech.tech_keywords || "").split(',').map(s => s.trim()).filter(Boolean);
            if (searchTerms.length === 0) {
                logMessages.push(`警告: 技术 '${tech.tech_name}' 没有配置开源搜索词，跳过。`);
                continue;
            }

            for (const sourceConfig of opensourceSources) { // ✅ 遍历所有开源数据源
              for (const term of searchTerms) {
                logMessages.push(`正在从 ${sourceConfig.display_name} 为技术 '${tech.tech_name}' 搜索开源项目: '${term}'...`);
                
                try {
                  let projectsData = [];
                  if (sourceConfig.source_id === 'GITHUB_API') {
                    const queryParams = { q: term, sort: 'updated', order: 'desc', per_page: 5 };
                    const responseJson = DataConnector.fetchExternalData(sourceConfig, 'search_repositories', queryParams); // 假设 endpoint_paths 有 'search_repositories'

                    projectsData = (responseJson.items || []).filter(p => p.stargazers_count >= 50); // 过滤掉星数过低的项目
                  }
                  // ... 可以添加更多开源数据源的特定处理 ...

                  for (const project of projectsData) {
                    const duplicateHash = this._bytesToHex(Utilities.computeDigest(Utilities.DigestAlgorithm.MD5, project.html_url));
                    if (existingHashes.has(duplicateHash)) {
                        logMessages.push(`  -> 发现重复开源项目，跳过: ${project.full_name.substring(0,30)}... (Hash: ${duplicateHash})`);
                        duplicateCount++;
                        continue;
                    }

                    const raw_id = `RAW_OS_${Utilities.formatDate(new Date(), 'UTC', 'yyyyMMddHHmmssSSS')}_${duplicateHash.substring(0, 6)}`;
                    
                    // AI 预处理部分保持不变
                    logMessages.push(`  -> 正在为开源项目 "${project.full_name.substring(0,30)}..." 生成 AI 摘要/关键词/向量...`);
                    const aiPrompt = `请为以下开源项目生成一个不超过80字的精炼摘要，和3-5个最核心的技术关键词（以逗号分隔）。\n\n项目名称: ${project.full_name}\n描述: ${project.description || ''}`;
                    const aiResponse = this._callAIForTextGeneration(aiPrompt);

                    let ai_summary = "";
                    let ai_keywords = "";
                    const lines = aiResponse ? aiResponse.split('\n') : [];
                    if (lines.length > 0) {
                        ai_summary = lines[0].trim();
                        if (lines.length > 1 && lines[1].toLowerCase().includes('关键词')) {
                            ai_keywords = lines[1].replace(/关键词[:：]/gi, '').trim();
                        } else if (lines.length > 1) {
                            ai_keywords = lines.find(line => line.toLowerCase().includes('关键词')) || lines[1];
                            ai_keywords = ai_keywords.replace(/关键词[:：]/gi, '').trim();
                        }
                    }
                    
                    const textForEmbedding = `${project.full_name} ${ai_summary} ${ai_keywords}`;
                    const embeddingVector = this._callAIForEmbedding(textForEmbedding);

                    const projectDataObject = {
                        raw_id: raw_id,
                        id: raw_id,
                        source_type: 'opensource_data',
                        project_name: project.full_name,
                        description: (project.description || '').substring(0, 500),
                        main_language: project.language || '',
                        source_url: project.html_url,
                        github_stars: project.stargazers_count,
                        github_forks: project.forks_count,
                        last_commit_date: new Date(project.updated_at),
                        contributor_count: project.watchers_count,
                        tech_keywords: tech.tech_keywords,
                        ai_summary: ai_summary,
                        ai_keywords: ai_keywords,
                        embedding: embeddingVector,
                        processing_status: 'pending',
                        workflow_execution_id: executionId,
                        created_timestamp: new Date(),
                        last_update_timestamp: new Date(),
                        duplicate_check_hash: duplicateHash
                    };
                    allNewProjectsObjects.push(projectDataObject);
                    successCount++;
                  }
                } catch (sourceError) {
                  logMessages.push(`警告: 从数据源 ${sourceConfig.display_name} 获取数据失败: ${sourceError.message}`);
                  errorCount++;
                }
              }
            }
          }

          if (allNewProjectsObjects.length > 0) {
            DataService.batchUpsert('RAW_OPENSOURCE_DATA', allNewProjectsObjects, 'raw_id');
            logMessages.push(`成功写入 ${allNewProjectsObjects.length} 条开源项目数据（含AI预处理）。`);
          }
          
          const finalMessage = `成功处理 ${processedCount} 个技术领域，从 ${opensourceSources.length} 个源发现并写入了 ${successCount} 个相关开源项目，跳过 ${duplicateCount} 条重复项目。`;
          this._logExecution(wfName, executionId, startTime, 'completed', processedCount, successCount, errorCount, finalMessage);
          return { success: true, message: finalMessage, log: logMessages.join('\n') };

        } catch (e) {
          const errorMessage = `严重错误: ${e.message}`;
          this._logExecution(wfName, executionId, startTime, 'failed', processedCount, successCount, errorCount + 1, errorMessage);
          return { success: false, message: errorMessage, log: logMessages.join('\n') };
        }
      },

      // --- WF4: 技术新闻获取 (示例修改) ---
      runWf4_TechNews: function() {
        const wfName = 'WF4: 技术新闻获取';
        const startTime = new Date();
        const executionId = `exec_wf4_${startTime.getTime()}`;
        let logMessages = [`[${new Date().toLocaleTimeString()}] ${wfName} (${executionId}) 开始执行...`];
        let successCount = 0, processedCount = 0, errorCount = 0, duplicateCount = 0;

        try {
          const techRegistry = DataService.getDataAsObjects('TECH_REGISTRY').filter(t => t.monitoring_status === 'active' && t.data_source_news === true);
          const competitorRegistry = DataService.getDataAsObjects('COMPETITOR_REGISTRY').filter(c => c.monitoring_status === 'active' && c.news_monitoring === true);
          
          const searchEntities = [...techRegistry, ...competitorRegistry];
          processedCount = searchEntities.length;
          logMessages.push(`发现 ${techRegistry.length} 个技术监控项和 ${competitorRegistry.length} 个业绩标杆监控项。`);

          if (searchEntities.length === 0) {
            const msg = "没有需要监控新闻的活跃实体。";
            this._logExecution(wfName, executionId, startTime, 'completed', 0, 0, 0, msg);
            return { success: true, message: msg, log: logMessages.join('\n') };
          }

          let allNewArticles = [];
          const existingHashes = new Set(
              (DataService.getDataAsObjects('RAW_TECH_NEWS') || [])
              .map(item => item.duplicate_check_hash)
              .filter(Boolean)
          );
          logMessages.push(`  -> 现有 ${existingHashes.size} 条历史记录用于去重检查。`);

          // ✅ 动态获取所有活跃的新闻数据源
          const newsSources = DataConnector.getAllActiveSourcesOfType('news_source');
          if (newsSources.length === 0) {
            this._logExecution(wfName, executionId, startTime, 'completed', 0, 0, 0, "没有配置活跃的新闻数据源。");
            return { success: true, message: "没有配置活跃的新闻数据源。", log: logMessages.join('\n') };
          }
          logMessages.push(`发现 ${newsSources.length} 个活跃的新闻数据源: ${newsSources.map(s => s.display_name).join(', ')}`);


          for (const entity of searchEntities) {
            const isTech = !!entity.tech_name;
            const query = isTech ? `"${entity.tech_name}" OR (${(entity.tech_keywords || '').replace(/,/g, ' OR ')})` : `"${entity.company_name}"`;
            logMessages.push(`正在为 '${isTech ? entity.tech_name : entity.company_name}' 搜索新闻...`);

            for (const sourceConfig of newsSources) { // ✅ 遍历所有新闻数据源
              try {
                let articlesData = [];
                if (sourceConfig.source_id === 'NEWSAPI_ORG') {
                  const queryParams = { q: query, pageSize: 5 };
                  const responseJson = DataConnector.fetchExternalData(sourceConfig, 'everything', queryParams);
                  articlesData = responseJson.articles || [];
                }
                // ... 可以添加更多新闻数据源的特定处理 ...

                for (const article of articlesData) {
                    const duplicateHash = this._bytesToHex(Utilities.computeDigest(Utilities.DigestAlgorithm.MD5, article.url));
                    if (existingHashes.has(duplicateHash)) {
                        logMessages.push(`  -> 发现重复新闻，跳过: ${article.title.substring(0,30)}... (Hash: ${duplicateHash})`);
                        duplicateCount++;
                        continue;
                    }

                    logMessages.push(`  -> 正在为新闻 "${(article.title || "").substring(0,30)}..." 生成 AI 摘要/关键词/向量...`);
                    const aiPrompt = `请为以下新闻生成一个不超过60字的精炼摘要，和3-5个最核心的关键词（以逗号分隔）。\n\n标题: ${article.title}\n摘要: ${article.description || ''}`;
                    const aiResponse = this._callAIForTextGeneration(aiPrompt);

                    let ai_summary = "";
                    let ai_keywords = "";
                    const lines = aiResponse ? aiResponse.split('\n') : [];
                    if (lines.length > 0) {
                        ai_summary = lines[0].trim();
                        if (lines.length > 1 && lines[1].toLowerCase().includes('关键词')) {
                            ai_keywords = lines[1].replace(/关键词[:：]/gi, '').trim();
                        } else if (lines.length > 1) {
                            ai_keywords = lines.find(line => line.toLowerCase().includes('关键词')) || lines[1];
                            ai_keywords = ai_keywords.replace(/关键词[:：]/gi, '').trim();
                        }
                    }
                    
                    const textForEmbedding = `${article.title} ${ai_summary} ${ai_keywords}`;
                    const embeddingVector = this._callAIForEmbedding(textForEmbedding);

                    const raw_id = `RAW_TN_${Utilities.formatDate(new Date(), 'UTC', 'yyyyMMddHHmmssSSS')}_${duplicateHash.substring(0, 6)}`;

                    const newsDataObject = {
                      raw_id: raw_id,
                      id: raw_id,
                      source_type: 'tech_news',
                      news_title: article.title,
                      news_summary: (article.description || '').substring(0, 500),
                      source_url: article.url,
                      publication_date: new Date(article.publishedAt),
                      source_platform: article.source.name,
                      author: article.author || '',
                      related_companies: isTech ? '' : entity.company_name,
                      tech_keywords: isTech ? entity.tech_keywords : '',
                      ai_summary: ai_summary,
                      ai_keywords: ai_keywords,
                      embedding: embeddingVector,
                      processing_status: 'pending',
                      news_value_score: 0,
                      market_impact_score: 0,
                      duplicate_check_hash: duplicateHash,
                      workflow_execution_id: executionId,
                      created_timestamp: new Date(),
                      last_update_timestamp: new Date()
                    };

                    allNewArticles.push(newsDataObject);
                    successCount++;
                  }
                } catch (sourceError) {
                  logMessages.push(`警告: 从数据源 ${sourceConfig.display_name} 获取数据失败: ${sourceError.message}`);
                  errorCount++;
                }
              }
            }
          
          if (allNewArticles.length > 0) {
            DataService.batchUpsert('RAW_TECH_NEWS', allNewArticles, 'raw_id');
            logMessages.push(`成功写入 ${allNewArticles.length} 条新新闻数据（含AI预处理）。`);
          }

          const finalMessage = `成功处理 ${processedCount} 个实体，从 ${newsSources.length} 个源发现 ${successCount} 篇高价值文章，跳过 ${duplicateCount} 条重复文章。`;
          this._logExecution(wfName, executionId, startTime, 'completed', processedCount, successCount, errorCount, finalMessage);
          return { success: true, message: finalMessage, log: logMessages.join('\n') };

        } catch (e) {
          const errorMessage = `严重错误: ${e.message}`;
          this._logExecution(wfName, executionId, startTime, 'failed', processedCount, successCount, errorCount + 1, errorMessage);
          return { success: false, message: errorMessage, log: logMessages.join('\n') };
        }
      },

      // --- WF5: 产业动态捕获 (示例修改) ---
      runWf5_IndustryDynamics: function() {
        const wfName = 'WF5: 产业动态/会议新闻捕获';
        const startTime = new Date();
        const executionId = `exec_wf5_${startTime.getTime()}`;
        let logMessages = [`[${new Date().toLocaleTimeString()}] ${wfName} (${executionId}) 开始执行...`];
        let successCount = 0, processedCount = 0, errorCount = 0, duplicateCount = 0;

        try {
          const conferenceRegistry = DataService.getDataAsObjects('CONFERENCE_REGISTRY');
          if (!conferenceRegistry) {
              throw new Error("无法从 'CONFERENCE_REGISTRY' 获取数据，可能集合不存在或为空。");
          }
          
          const activeConferences = conferenceRegistry.filter(c => c.monitoring_status && String(c.monitoring_status).toLowerCase() === 'active');
          processedCount = activeConferences.length;
          logMessages.push(`发现 ${processedCount} 个需要监控的活跃会议。`);

          if (processedCount === 0) {
            const msg = "在 Conference_Registry 中没有找到 'monitoring_status' 为 'active' 的会议。";
            this._logExecution(wfName, executionId, startTime, 'completed', 0, 0, 0, msg);
            return { success: true, message: msg, log: logMessages.join('\n') };
          }

          let allNewDynamicsObjects = [];
          const existingHashes = new Set(
              (DataService.getDataAsObjects('RAW_INDUSTRY_DYNAMICS') || [])
              .map(item => item.duplicate_check_hash)
              .filter(Boolean)
          );
          logMessages.push(`  -> 现有 ${existingHashes.size} 条历史记录用于去重检查。`);

          // ✅ 动态获取所有活跃的新闻数据源
          const newsSources = DataConnector.getAllActiveSourcesOfType('news_source'); // 产业动态也用新闻源
          if (newsSources.length === 0) {
            this._logExecution(wfName, executionId, startTime, 'completed', 0, 0, 0, "没有配置活跃的新闻数据源用于产业动态。");
            return { success: true, message: "没有配置活跃的新闻数据源用于产业动态。", log: logMessages.join('\n') };
          }
          logMessages.push(`发现 ${newsSources.length} 个活跃的新闻数据源: ${newsSources.map(s => s.display_name).join(', ')}`);


          for (const conf of activeConferences) {
            const query = `"${conf.conference_name}" OR "${conf.conference_id}"`;
            logMessages.push(`正在为会议 '${conf.conference_name}' 搜索相关新闻...`);

            for (const sourceConfig of newsSources) { // ✅ 遍历所有新闻数据源
              try {
                let articlesData = [];
                if (sourceConfig.source_id === 'NEWSAPI_ORG') {
                  const queryParams = { q: query, pageSize: 5 };
                  const responseJson = DataConnector.fetchExternalData(sourceConfig, 'everything', queryParams);
                  articlesData = responseJson.articles || [];
                }
                // ... 可以添加更多新闻数据源的特定处理 ...

                for (const article of articlesData) {
                    const duplicateHash = this._bytesToHex(Utilities.computeDigest(Utilities.DigestAlgorithm.MD5, article.url));
                    if (existingHashes.has(duplicateHash)) {
                        logMessages.push(`  -> 发现重复产业动态文章，跳过: ${article.title.substring(0,30)}... (Hash: ${duplicateHash})`);
                        duplicateCount++;
                        continue;
                    }

                    logMessages.push(`  -> 正在为产业动态 "${(article.title || "").substring(0,30)}..." 生成 AI 摘要/关键词/向量...`);
                    const aiPrompt = `请为以下产业动态新闻生成一个不超过80字的精炼摘要，和3-5个最核心的关键词（以逗号分隔）。\n\n标题: ${article.title}\n摘要: ${article.description || ''}`;
                    const aiResponse = this._callAIForTextGeneration(aiPrompt);

                    let ai_summary = "";
                    let ai_keywords = "";
                    const lines = aiResponse ? aiResponse.split('\n') : [];
                    if (lines.length > 0) {
                        ai_summary = lines[0].trim();
                        if (lines.length > 1 && lines[1].toLowerCase().includes('关键词')) {
                            ai_keywords = lines[1].replace(/关键词[:：]/gi, '').trim();
                        } else if (lines.length > 1) {
                            ai_keywords = lines.find(line => line.toLowerCase().includes('关键词')) || lines[1];
                            ai_keywords = ai_keywords.replace(/关键词[:：]/gi, '').trim();
                        }
                    }
                    
                    const textForEmbedding = `${article.title} ${ai_summary} ${ai_keywords}`;
                    const embeddingVector = this._callAIForEmbedding(textForEmbedding);

                    // --- 新增：AI识别相关公司 --
                    const companyPrompt = `请作为一名资深的市场分析师，从以下产业动态新闻中识别并提取所有提及的公司名称。
                      如果新闻内容中未明确提及公司，则返回空列表。
                      请严格以JSON数组格式返回公司名称（例如：["公司A", "公司B"]）。
                      新闻标题: ${article.title}
                      新闻摘要: ${article.description || ''}`;
                    
                    let relatedCompanies = [];
                    try {
                        const aiCompanyResponse = this._callAIForScoring(companyPrompt, { wfName, logMessages });
                        if (aiCompanyResponse && aiCompanyResponse.companies && Array.isArray(aiCompanyResponse.companies)) {
                            relatedCompanies = aiCompanyResponse.companies.map(c => String(c).trim()).filter(Boolean);
                        } else if (aiCompanyResponse && Array.isArray(aiCompanyResponse)) {
                            relatedCompanies = aiCompanyResponse.map(c => String(c).trim()).filter(Boolean);
                        } else {
                            logMessages.push(`警告: AI识别公司返回了非预期格式: ${JSON.stringify(aiCompanyResponse).substring(0, 100)}...`);
                        }
                    } catch (e) {
                        logMessages.push(`警告: AI识别相关公司失败: ${e.message}`);
                        relatedCompanies = [];
                    }
                    // --- 新增结束 ---

                    const raw_id = `RAW_ID_${Utilities.formatDate(new Date(), 'UTC', 'yyyyMMddHHmmssSSS')}_${duplicateHash.substring(0, 6)}`;

                    const dynamicsDataObject = {
                      raw_id: raw_id,
                      id: raw_id,
                      source_type: 'industry_dynamics',
                      event_title: article.title,
                      event_summary: (article.description || '').substring(0, 500),
                      source_url: article.url,
                      publication_date: new Date(article.publishedAt),
                      source_platform: article.source.name,
                      event_type: 'Conference News',
                      tech_keywords: conf.industry_focus,
                      industry_category: conf.industry_focus,
                      ai_summary: ai_summary,
                      ai_keywords: ai_keywords,
                      embedding: embeddingVector,
                      related_companies: relatedCompanies, // <-- 将 AI 识别的公司添加到数据对象
                      processing_status: 'pending',
                      workflow_execution_id: executionId,
                      created_timestamp: new Date(),
                      last_update_timestamp: new Date(),
                      duplicate_check_hash: duplicateHash
                    };
                    allNewDynamicsObjects.push(dynamicsDataObject);
                    successCount++;
                  }
                } catch (sourceError) {
                  logMessages.push(`警告: 从数据源 ${sourceConfig.display_name} 获取数据失败: ${sourceError.message}`);
                  errorCount++;
                }
              }
            }

          if (allNewDynamicsObjects.length > 0) {
            DataService.batchUpsert('RAW_INDUSTRY_DYNAMICS', allNewDynamicsObjects, 'raw_id');
            logMessages.push(`成功写入 ${allNewDynamicsObjects.length} 条新产业动态数据（含AI预处理）。`);
          }

          const finalMessage = `成功处理 ${processedCount} 个会议，从 ${newsSources.length} 个源发现 ${successCount} 条相关新闻，跳过 ${duplicateCount} 条重复文章。`;
          this._logExecution(wfName, executionId, startTime, 'completed', processedCount, successCount, errorCount, finalMessage);
          return { success: true, message: finalMessage, log: logMessages.join('\n') };

        } catch (e) {
          const errorMessage = `严重错误: ${e.message}`;
          this._logExecution(wfName, executionId, startTime, 'failed', processedCount, successCount, errorCount + 1, errorMessage);
          return { success: false, message: errorMessage, log: logMessages.join('\n') };
        }
      },

      // --- WF6: 竞争对手情报收集 (示例修改) ---
      runWf6_Benchmark: function() {
        const wfName = 'WF6: 竞争对手情报收集';
        const startTime = new Date();
        const executionId = `exec_wf6_${startTime.getTime()}`;
        let logMessages = [`[${new Date().toLocaleTimeString()}] ${wfName} (${executionId}) 开始执行...`];
        let successCount = 0, processedCount = 0, errorCount = 0, duplicateCount = 0;

        try {
          const competitorRegistry = DataService.getDataAsObjects('COMPETITOR_REGISTRY');
          if (!competitorRegistry) {
            throw new Error("无法从 'COMPETITOR_REGISTRY' 获取数据。");
          }
          
          const activeCompetitors = competitorRegistry.filter(c => 
            c.monitoring_status === 'active' &&
            c.news_monitoring === true
          );

          processedCount = activeCompetitors.length;
          logMessages.push(`发现 ${processedCount} 个需要监控新闻的活跃竞争对手。`);

          if (processedCount === 0) {
            const msg = "在 Competitor_Registry 中没有找到需要监控新闻的活跃竞争对手。";
            this._logExecution(wfName, executionId, startTime, 'completed', 0, 0, 0, msg);
            return { success: true, message: msg, log: logMessages.join('\n') };
          }

          let allNewIntelObjects = [];
          
          const existingHashes = new Set(
              (DataService.getDataAsObjects('RAW_COMPETITOR_INTELLIGENCE') || [])
              .map(item => item.duplicate_check_hash)
              .filter(Boolean)
          );
          logMessages.push(`  -> 现有 ${existingHashes.size} 条历史记录用于去重检查。`);

          // ✅ 动态获取所有活跃的新闻数据源
          const newsSources = DataConnector.getAllActiveSourcesOfType('news_source'); // 竞情也用新闻源
          if (newsSources.length === 0) {
            this._logExecution(wfName, executionId, startTime, 'completed', 0, 0, 0, "没有配置活跃的新闻数据源用于竞争情报。");
            return { success: true, message: "没有配置活跃的新闻数据源用于竞争情报。", log: logMessages.join('\n') };
          }
          logMessages.push(`发现 ${newsSources.length} 个活跃的新闻数据源: ${newsSources.map(s => s.display_name).join(', ')}`);


          for (const competitor of activeCompetitors) {
            const query = `"${competitor.company_name}"`;
            logMessages.push(`正在为竞争对手 '${competitor.company_name}' 搜索新闻...`);

            for (const sourceConfig of newsSources) { // ✅ 遍历所有新闻数据源
              try {
                let articlesData = [];
                if (sourceConfig.source_id === 'NEWSAPI_ORG') {
                  const queryParams = { q: query, pageSize: 5 };
                  const responseJson = DataConnector.fetchExternalData(sourceConfig, 'everything', queryParams);
                  articlesData = responseJson.articles || [];
                }
                // ... 可以添加更多新闻数据源的特定处理 ...

                for (const article of articlesData) {
                  const duplicateHash = this._bytesToHex(Utilities.computeDigest(Utilities.DigestAlgorithm.MD5, article.url));
                  
                  if (existingHashes.has(duplicateHash)) {
                      logMessages.push(`  -> 发现重复文章，跳过: ${article.title.substring(0,30)}... (Hash: ${duplicateHash})`);
                      duplicateCount++;
                      continue;
                  }

                  logMessages.push(`  -> 正在为竞争情报 "${(article.title || "").substring(0,30)}..." 生成 AI 摘要/关键词/向量...`);
                  const aiPrompt = `请为以下关于竞争对手的新闻情报生成一个不超过80字的精炼摘要，和3-5个最核心的关键词（以逗号分隔）。\n\n标题: ${article.title}\n摘要: ${article.description || ''}`;
                  const aiResponse = this._callAIForTextGeneration(aiPrompt);

                  let ai_summary = "";
                  let ai_keywords = "";
                  const lines = aiResponse ? aiResponse.split('\n') : [];
                  if (lines.length > 0) {
                      ai_summary = lines[0].trim();
                      if (lines.length > 1 && lines[1].toLowerCase().includes('关键词')) {
                          ai_keywords = lines[1].replace(/关键词[:：]/gi, '').trim();
                      } else if (lines.length > 1) {
                          ai_keywords = lines.find(line => line.toLowerCase().includes('关键词')) || lines[1];
                          ai_keywords = ai_keywords.replace(/关键词[:：]/gi, '').trim();
                      }
                  }
                  
                  const textForEmbedding = `${article.title} ${ai_summary} ${ai_keywords}`;
                  const embeddingVector = this._callAIForEmbedding(textForEmbedding);

                  const raw_id = `RAW_CI_${Utilities.formatDate(new Date(), 'UTC', 'yyyyMMddHHmmssSSS')}_${duplicateHash.substring(0, 6)}`;

                  const intelDataObject = {
                    raw_id: raw_id,
                    id: raw_id,
                    source_type: 'competitor_intelligence',
                    intelligence_title: article.title,
                    intelligence_summary: (article.description || '').substring(0, 500),
                    source_url: article.url,
                    publication_date: new Date(article.publishedAt),
                    source_platform: article.source.name,
                    author: article.author || '',
                    competitor_name: competitor.company_name,
                    intelligence_type: 'General News', // 初始类型，待 WF7-6 中由 AI 细化
                    tech_keywords: '', // 留空，待 AI 分析
                    ai_summary: ai_summary,
                    ai_keywords: ai_keywords,
                    embedding: embeddingVector,
                    processing_status: 'pending',
                    threat_level_score: 0,
                    business_impact_score: 0,
                    duplicate_check_hash: duplicateHash,
                    workflow_execution_id: executionId,
                    created_timestamp: new Date(),
                    last_update_timestamp: new Date()
                  };
                  allNewIntelObjects.push(intelDataObject);
                  successCount++;
                }
              } catch (sourceError) {
                logMessages.push(`警告: 从数据源 ${sourceConfig.display_name} 获取数据失败: ${sourceError.message}`);
                errorCount++;
              }
            }
          }

          if (allNewIntelObjects.length > 0) {
            DataService.batchUpsert('RAW_COMPETITOR_INTELLIGENCE', allNewIntelObjects, 'raw_id');
            logMessages.push(`成功写入 ${allNewIntelObjects.length} 条新竞争情报数据（含AI预处理）。`);
          }

          const finalMessage = `成功处理 ${processedCount} 个竞争对手，从 ${newsSources.length} 个源发现 ${successCount} 条新文章，跳过 ${duplicateCount} 条重复文章。`;
          this._logExecution(wfName, executionId, startTime, 'completed', processedCount, successCount, errorCount, finalMessage);
          return { success: true, message: finalMessage, log: logMessages.join('\n') };

        } catch (e) {
          const errorMessage = `严重错误: ${e.message}`;
          this._logExecution(wfName, executionId, startTime, 'failed', processedCount, successCount, errorCount + 1, errorMessage);
          return { success: false, message: errorMessage, log: logMessages.join('\n') };
        }
      },

      // --- _callAIForScoring 辅助函数 (示例修改) ---
      _callAIForScoring: function(prompt, logContext) {
        const { wfName, logMessages } = logContext;
        try {
          // ✅ 动态获取 OpenAI Chat API 服务配置
          const llmServiceConfig = DataConnector.getSourceConfig('llm_service', 'OPENAI_API');
          
          const payload = {
            model: "gpt-4o-mini", // 使用性价比高的新模型
            messages: [{ role: "user", content: prompt }],
            response_format: { type: "json_object" }, // 强制要求返回JSON对象
            temperature: 0.2, // 对于评分任务，使用较低的温度以保证结果的稳定性
            max_tokens: 500
          };

          const requestOptions = {
            method: "post",
            contentType: "application/json",
            // headers 和 payload 会由 DataConnector 动态处理
          };

          const responseJson = DataConnector.fetchExternalData(llmServiceConfig, 'chat_completions', payload, requestOptions);

          if (responseJson.choices && responseJson.choices.length > 0 && responseJson.choices[0].message) {
            return JSON.parse(responseJson.choices[0].message.content);
          } else {
            throw new Error("AI响应格式不正确，缺少choices或message。");
          }
        } catch (e) {
          Logger.log(`[${wfName}] AI调用失败: ${e.message}`);
          if (logMessages) {
              logMessages.push(`警告: AI评估失败 - ${e.message}`);
          }
          return null;
        }
      },

      // --- _callAIForTextGeneration 辅助函数 (示例修改) ---
      _callAIForTextGeneration: function(prompt, options = {}) {
        Logger.log(`[AI-TextGen] Calling AI for text generation. Prompt snippet: ${prompt.substring(0, 100)}...`);
        try {
          const llmServiceConfig = DataConnector.getSourceConfig('llm_service', 'OPENAI_API');

          const model = options.model || "gpt-4o-mini";
          const temperature = options.temperature || 0.5;
          const max_tokens = options.max_tokens || 300;

          const payload = {
            model: model,
            messages: [{ role: "user", content: prompt }],
            max_tokens: max_tokens,
            temperature: temperature
          };

          const requestOptions = {
            method: "post",
            contentType: "application/json",
          };

          const responseJson = DataConnector.fetchExternalData(llmServiceConfig, 'chat_completions', payload, requestOptions);

          if (responseJson.choices && responseJson.choices.length > 0 && responseJson.choices[0].message) {
            return responseJson.choices[0].message.content.trim();
          } else {
            Logger.log(`[AI-TextGen] API Error: ${responseJson.error || JSON.stringify(responseJson)}`);
            return `AI生成失败：API错误 (${responseJson.error ? responseJson.error.message : '未知错误'})。`;
          }
        } catch (e) {
          Logger.log(`[AI-TextGen] API调用失败: ${e.message}\n${e.stack}`);
          return `AI生成失败：连接或解析错误 (${e.message})。`;
        }
      },

      // --- _callAIForEmbedding 辅助函数 (示例修改) ---
      _callAIForEmbedding: function(text, options = {}) {
        Logger.log(`[AI-Embedding] Calling AI for embedding. Text snippet: ${String(text).substring(0, 50)}...`);
        try {
          const llmServiceConfig = DataConnector.getSourceConfig('llm_service', 'OPENAI_API');

          const model = options.model || "text-embedding-3-small";

          const payload = {
            input: text,
            model: model
          };

          const requestOptions = {
            method: "post",
            contentType: "application/json",
          };

          const responseJson = DataConnector.fetchExternalData(llmServiceConfig, 'embeddings', payload, requestOptions);

          if (responseJson.data && responseJson.data.length > 0) {
            return responseJson.data[0].embedding;
          } else {
            Logger.log(`[AI-Embedding] API Error: ${responseJson.error || JSON.stringify(responseJson)}`);
            return null;
          }
        } catch (e) {
          Logger.log(`[AI-Embedding] API调用失败: ${e.message}\n${e.stack}`);
          return null;
        }
      },

      // --- _generateChartImage 辅助函数 (示例修改) ---
      _generateChartImage: function(chartConfig, fileName) {
        const wfName = 'Chart Generation';
        const startTime = new Date();
        const executionId = `exec_chart_${startTime.getTime()}`;
        let logMessages = [`[${new Date().toLocaleTimeString()}] ${wfName} (${executionId}) 开始执行...`];
        
        const maxRetries = 3;
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                Logger.log(`开始生成图表 '${fileName}' (尝试第 ${attempt} 次)...`);

                // ✅ 动态获取 QuickChart 服务配置
                const quickChartServiceConfig = DataConnector.getSourceConfig('chart_service', 'QUICKCHART_IO'); // 假设您已在 Firestore 配置 QUICKCHART_IO
                const qcPayload = { backgroundColor: '#ffffff', width: 720, height: 400, chart: chartConfig };
                
                const qcResponseBlob = DataConnector.fetchExternalData(
                    quickChartServiceConfig,
                    'chart_endpoint', // 假设 QuickChart 的图表生成端点键为 'chart_endpoint'
                    qcPayload,
                    { method: 'post', payload_type: 'json', response_type: 'blob' } // 明确指出期望返回 blob
                );

                if (!qcResponseBlob || qcResponseBlob.getBytes().length === 0) {
                    throw new Error("QuickChart 返回空响应或无效图像。");
                }
                const imageBase64 = Utilities.base64Encode(qcResponseBlob.getBytes());
                const fileDataUri = `data:image/png;base64,${imageBase64}`;

                // ✅ 动态获取 Cloudinary 服务配置
                const cloudinaryServiceConfig = DataConnector.getSourceConfig('image_cdn', 'CLOUDINARY_COM'); // 假设您已在 Firestore 配置 CLOUDINARY_COM
                const timestamp = String(Math.round(new Date().getTime() / 1000));
                const folder = 'deepdive_reports';
                const publicId = `${fileName.replace('.png', '')}_${timestamp}`;
                
                const cloudinaryPayload = {
                    file: fileDataUri,
                    api_key: cloudinaryServiceConfig.apiKey, // 从 DataConnector 获取
                    timestamp: timestamp,
                    signature: this._generateCloudinarySignature({ timestamp, folder, public_id: publicId }, PropertiesService.getScriptProperties().getProperty(cloudinaryServiceConfig.api_key_name + '_SECRET')), // Cloudinary 签名需要 secret
                    folder: folder,
                    public_id: publicId
                };

                const cloudinaryResponseJson = DataConnector.fetchExternalData(
                    cloudinaryServiceConfig,
                    'upload_endpoint', // 假设 Cloudinary 的上传端点键为 'upload_endpoint'
                    cloudinaryPayload,
                    { method: 'post', payload_type: 'form_urlencoded' } // Cloudinary 上传通常是 form-urlencoded
                );

                if (cloudinaryResponseJson && cloudinaryResponseJson.secure_url) {
                    const imageUrl = cloudinaryResponseJson.secure_url;
                    Logger.log(`成功上传图表到 Cloudinary: ${imageUrl}`);
                    this._logExecution(wfName, executionId, startTime, 'completed', 1, 1, 0, `图表生成成功: ${imageUrl}`);
                    return imageUrl;
                } else {
                    throw new Error(`Cloudinary 上传失败: ${JSON.stringify(cloudinaryResponseJson)}`);
                }

            } catch (e) {
                Logger.log(`在 _generateChartImage (尝试 ${attempt}) 中发生错误: ${e.message}`);
                if (attempt < maxRetries) Utilities.sleep(2000);
            }
        }

        Logger.log(`!!! 生成图表 '${fileName}' 在 ${maxRetries} 次尝试后彻底失败。`);
        this._logExecution(wfName, executionId, startTime, 'failed', 1, 0, 1, `图表生成失败: ${e.message}`);
        return null;
      },
      // ... 剩余 WorkflowsService 代码 ...
    };
    ```

**2.2. 测试工作流 (`backend/test.Workflows.gs`)**

*   **操作：** 创建文件 `backend/test.Workflows.gs`，并粘贴以下测试代码。
*   **运行：** 在 Apps Script 编辑器中，从函数列表中选择 `test_Workflows_All()` 并运行。查看 `执行日志` 和 Firestore 集合中的数据变化。

```javascript
// 文件名: backend/test.Workflows.gs

function test_Workflows_All() {
  console.log("=====================================================");
  console.log("--- Starting Workflows Integration Tests ---");
  console.log("=====================================================");

  try {
    // 确保 DataConnector 缓存是空的，从 Firestore 重新读取最新配置
    DataConnector.clearCache();

    // 确保有测试用的技术领域/竞争对手/会议配置
    // 如果没有，请在 Firestore 的 technology_registry / competitor_registry / conference_registry 中添加测试数据
    // 例如，在 technology_registry 中添加一条：
    // { tech_id: "test_ai", tech_name: "人工智能", monitoring_status: "active", data_source_academic: true, academic_search_terms: "artificial intelligence, machine learning" }
    // { tech_id: "test_blockchain", tech_name: "区块链", monitoring_status: "active", data_source_opensource: true, tech_keywords: "blockchain, cryptocurrency" }
    // { competitor_id: "test_comp_a", company_name: "TestCorp A", monitoring_status: "active", news_monitoring: true }
    // { conference_id: "test_conf_b", conference_name: "AI Summit", monitoring_status: "active", industry_focus: "AI" }

    test_Workflows_WF1_AcademicPapers();
    test_Workflows_WF2_PatentData(); // ⚠️ 需要在 external_data_sources 中配置 PATENT_API_MOCK 或真实专利API
    test_Workflows_WF3_OpenSource(); // ⚠️ 需要在 external_data_sources 中配置 GITHUB_API，并设置 GITHUB_API_KEY
    test_Workflows_WF4_TechNews();
    test_Workflows_WF5_IndustryDynamics();
    test_Workflows_WF6_Benchmark();
    // WF7-WF8 的测试可以放在 InsightService 的测试中，因为它们依赖前面采集的数据

    console.log("\n=====================================================");
    console.log("--- All Workflows Integration Tests Completed Successfully ---");
    console.log("=====================================================");

  } catch (e) {
    console.error("\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
    console.error(`!!! Workflows Integration Tests FAILED: ${e.message} !!!`);
    console.error(`Stack: ${e.stack}`);
    console.error("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
    throw e;
  }
}

function test_Workflows_WF1_AcademicPapers() {
  console.log("\n--- Running WF1: Academic Papers Integration Test ---");
  try {
    const result = WorkflowsService.runWf1_AcademicPapers();
    console.log(`WF1 Result: ${JSON.stringify(result)}`);
    console.assert(result.success === true, 'WF1 should succeed');
    console.log("--- WF1 Test Passed ---");
  } catch (e) {
    console.error(`❌ WF1 Test Failed: ${e.message}`);
    throw e;
  }
}

function test_Workflows_WF2_PatentData() {
  console.log("\n--- Running WF2: Patent Data Integration Test ---");
  try {
    // ⚠️ 前提：在 Firestore 的 external_data_sources 中添加 'PATENT_API_MOCK' 或其他真实的专利 API
    // 并且在 technology_registry 中有 active 且 data_source_patent 为 true 的技术领域。
    const result = WorkflowsService.runWf2_PatentData();
    console.log(`WF2 Result: ${JSON.stringify(result)}`);
    console.assert(result.success === true, 'WF2 should succeed');
    console.log("--- WF2 Test Passed ---");
  } catch (e) {
    console.error(`❌ WF2 Test Failed: ${e.message}`);
    throw e;
  }
}

function test_Workflows_WF3_OpenSource() {
  console.log("\n--- Running WF3: Open Source Integration Test ---");
  try {
    // ⚠️ 前提：在 Firestore 的 external_data_sources 中添加 'GITHUB_API'，并设置 GITHUB_API_KEY
    // 并且在 technology_registry 中有 active 且 data_source_opensource 为 true 的技术领域。
    const result = WorkflowsService.runWf3_OpenSource();
    console.log(`WF3 Result: ${JSON.stringify(result)}`);
    console.assert(result.success === true, 'WF3 should succeed');
    console.log("--- WF3 Test Passed ---");
  } catch (e) {
    console.error(`❌ WF3 Test Failed: ${e.message}`);
    throw e;
  }
}

function test_Workflows_WF4_TechNews() {
  console.log("\n--- Running WF4: Tech News Integration Test ---");
  try {
    // ⚠️ 前提：在 Firestore 的 external_data_sources 中添加 'NEWSAPI_ORG'，并设置 NEWS_API_KEY
    // 并且在 technology_registry 或 competitor_registry 中有 active 且 news_monitoring 为 true 的实体。
    const result = WorkflowsService.runWf4_TechNews();
    console.log(`WF4 Result: ${JSON.stringify(result)}`);
    console.assert(result.success === true, 'WF4 should succeed');
    console.log("--- WF4 Test Passed ---");
  } catch (e) {
    console.error(`❌ WF4 Test Failed: ${e.message}`);
    throw e;
  }
}

function test_Workflows_WF5_IndustryDynamics() {
  console.log("\n--- Running WF5: Industry Dynamics Integration Test ---");
  try {
    // ⚠️ 前提：在 Firestore 的 external_data_sources 中添加 'NEWSAPI_ORG'，并设置 NEWS_API_KEY
    // 并且在 conference_registry 中有 active 的会议。
    const result = WorkflowsService.runWf5_IndustryDynamics();
    console.log(`WF5 Result: ${JSON.stringify(result)}`);
    console.assert(result.success === true, 'WF5 should succeed');
    console.log("--- WF5 Test Passed ---");
  } catch (e) {
    console.error(`❌ WF5 Test Failed: ${e.message}`);
    throw e;
  }
}

function test_Workflows_WF6_Benchmark() {
  console.log("\n--- Running WF6: Benchmark Integration Test ---");
  try {
    // ⚠️ 前提：在 Firestore 的 external_data_sources 中添加 'NEWSAPI_ORG'，并设置 NEWS_API_KEY
    // 并且在 competitor_registry 中有 active 且 news_monitoring 为 true 的竞争对手。
    const result = WorkflowsService.runWf6_Benchmark();
    console.log(`WF6 Result: ${JSON.stringify(result)}`);
    console.assert(result.success === true, 'WF6 should succeed');
    console.log("--- WF6 Test Passed ---");
  } catch (e) {
    console.error(`❌ WF6 Test Failed: ${e.message}`);
    throw e;
  }
}
```

---

**第三阶段：管理界面开发与最终验证**

**3.1. 修改 `backend/svc.SystemAdminService.gs`**

*   **操作：** 在 `SystemAdminService._registryMap` 中添加 `EXTERNAL_DATA_SOURCES` 的定义。
*   **代码：**

    ```javascript
    // 文件名: backend/svc.SystemAdminService.gs (修改后)

    const SystemAdminService = {
      _registryMap: {
        // ... 现有注册表 (TECH_REGISTRY, COMPETITOR_REGISTRY, CONFERENCE_REGISTRY) ...

        // 新增外部数据源注册表定义
        EXTERNAL_DATA_SOURCES: {
          collection: CONFIG.FIRESTORE_COLLECTIONS.EXTERNAL_DATA_SOURCES, // 使用 CONFIG 中的常量
          idField: 'source_id',
          displayName: '外部数据源',
          fields: [
            { name: 'source_id', label: '源ID', type: 'text', required: true, editable: false },
            { name: 'display_name', label: '显示名称', type: 'text', required: true },
            { name: 'source_type', label: '源类型', type: 'select', options: ['academic_paper_source', 'patent_data_source', 'news_source', 'opensource_data_source', 'llm_service', 'chart_service', 'image_cdn', 'other'], required: true },
            { name: 'base_url', label: '基础URL', type: 'text', required: true },
            { name: 'endpoint_paths', label: 'API端点路径 (JSON)', type: 'textarea', notes: '如: {"query": "/api/query", "search": "/v1/search"}' },
            { name: 'request_method', label: '请求方法', type: 'select', options: ['GET', 'POST', 'PUT', 'DELETE'], required: true },
            { name: 'payload_type', label: '请求体类型', type: 'select', options: ['none', 'json', 'form_urlencoded', 'xml'], required: true },
            { name: 'response_type', label: '响应体类型', type: 'select', options: ['json', 'xml', 'text'], required: true },
            { name: 'auth_method', label: '认证方式', type: 'select', options: ['none', 'header_key', 'query_param_key', 'bearer_token', 'basic_auth'], required: true },
            { name: 'api_key_name', label: 'API Key名称 (ScriptProperties)', type: 'text', notes: '在Apps Script项目属性中存储的API Key的键名' },
            { name: 'api_key_header_name', label: 'API Key头名称', type: 'text', notes: '如 Authorization, X-Api-Key' },
            { name: 'api_key_query_param_name', label: 'API Key查询参数名', type: 'text', notes: '如 api_key' },
            { name: 'request_headers', label: '固定请求头 (JSON)', type: 'textarea', notes: '如: {"Accept": "application/json", "User-Agent": "MyAgent"}' },
            { name: 'fixed_query_params', label: '固定查询参数 (JSON)', type: 'textarea', notes: '如: {"version": "1", "format": "json"}' },
            { name: 'is_active', label: '是否启用', type: 'checkbox' },
            { name: 'priority', label: '优先级 (数字越大越优先)', type: 'number' },
            { name: 'rate_limit_per_minute', label: '每分钟请求限制', type: 'number' },
            { name: 'notes', label: '备注', type: 'textarea' },
            { name: 'last_successful_check', label: '上次成功检查时间', type: 'date', editable: false },
            { name: 'created_timestamp', label: '创建时间', type: 'date', editable: false },
            { name: 'last_updated_timestamp', type: 'date', label: '更新时间', editable: false }
          ]
        },
      },
      // ... 现有通用方法 ...
    };
    ```

**3.2. 修改 `MainContainer.html`**

*   **操作：** 在 `System` 页面下的 `registry-tabs` 导航中，添加一个用于“外部数据源”的 Tab。
*   **代码：** (在 `MainContainer.html` 中找到 `id="registry-tabs"` 的 `nav` 标签，添加以下 `<a>` 标签)

    ```html
    <!-- MainContainer.html -->
    <!-- ... -->
    <div id="system-tab-content-registries" class="system-sub-tab-content hidden">
      <!-- 注册表子导航 -->
      <div class="border-b border-gray-200 mb-4">
        <nav id="registry-tabs" class="-mb-px flex space-x-4" aria-label="Registry Tabs">
          <a href="#" class="registry-tab whitespace-nowrap py-2 px-1 border-b-2 font-medium text-base" data-registry="TECH_REGISTRY">技术领域</a>
          <a href="#" class="registry-tab whitespace-nowrap py-2 px-1 border-b-2 font-medium text-base" data-registry="COMPETITOR_REGISTRY">业界标杆</a>
          <a href="#" class="registry-tab whitespace-nowrap py-2 px-1 border-b-2 font-medium text-base" data-registry="CONFERENCE_REGISTRY">学术顶会</a>
          <a href="#" class="registry-tab whitespace-nowrap py-2 px-1 border-b-2 font-medium text-base" data-registry="EXTERNAL_DATA_SOURCES">外部数据源</a> <!-- 新增这行 -->
        </nav>
      </div>
      <!-- ... -->
    </div>
    <!-- ... -->
    ```

**3.3. 修改 `frontend/main.js.html`**

*   **操作：** 更新前端 JavaScript 逻辑，使其能够处理 `EXTERNAL_DATA_SOURCES` 注册表，特别是 `textarea` 类型的 JSON 字段的输入和输出。
*   **代码：** (在 `frontend/main.js.html` 中找到 `buildDynamicForm` 和 `collectFormData` 函数，并进行以下修改。请注意，这里只展示了关键的 `switch` 部分，您需要将其合并到您已有的函数中。)

    ```javascript
    // 文件名: frontend/main.js.html (修改后，只展示 buildDynamicForm 和 collectFormData 的相关部分)

    // ... (现有 DOMContentLoaded 逻辑和变量声明) ...

    // --- 8. 动态生成表单 ---
    function buildDynamicForm(registryType, formData = {}) {
      const registryConfig = allRegistryMetaData[registryType];
      const fields = registryConfig.fields;
      let formHtml = '';

      fields.forEach(field => {
        if (field.editable === false && currentEditEntryId) {
          if (formData[field.name]) {
            formHtml += `
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700">${field.label}</label>
                <p class="mt-1 p-2 border border-gray-200 rounded-md bg-gray-100 text-gray-600">${
                  (field.type === 'textarea' && field.notes && field.notes.includes('JSON')) ? JSON.stringify(formData[field.name], null, 2) : formData[field.name]
                }</p>
                <input type="hidden" name="${field.name}" value="${
                  (field.type === 'textarea' && field.notes && field.notes.includes('JSON')) ? JSON.stringify(formData[field.name]) : formData[field.name] || ''
                }">
              </div>
            `;
          }
          return;
        }

        let currentValue = formData[field.name];
        // 对于 JSON 字段，如果是对象则转为格式化字符串，否则保留原样
        if (field.type === 'textarea' && field.notes && field.notes.includes('JSON')) {
          try {
            currentValue = (typeof currentValue === 'object' && currentValue !== null) ? JSON.stringify(currentValue, null, 2) : '';
          } catch (e) {
            console.error(`Error stringifying JSON field ${field.name}:`, e);
            currentValue = 'Invalid JSON data';
          }
        } else if (Array.isArray(currentValue)) {
          currentValue = currentValue.join(', '); // 数组转为逗号分隔字符串
        } else if (currentValue === null || currentValue === undefined) {
          currentValue = '';
        }

        formHtml += `<div class="mb-4">`;
        formHtml += `<label for="${field.name}" class="block text-sm font-medium text-gray-700">${field.label}${field.required ? ' <span class="text-red-500">*</span>' : ''}</label>`;
        if (field.notes) {
          formHtml += `<p class="text-xs text-gray-500 mb-1">${field.notes}</p>`;
        }

        switch (field.type) {
          case 'text':
          case 'number':
          case 'date':
            formHtml += `<input type="${field.type}" id="${field.name}" name="${field.name}" value="${currentValue}" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-primary focus:border-primary" ${field.required ? 'required' : ''}>`;
            break;
          case 'textarea':
            formHtml += `<textarea id="${field.name}" name="${field.name}" rows="3" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-primary focus:border-primary" ${field.required ? 'required' : ''}>${currentValue}</textarea>`;
            break;
          case 'select':
            formHtml += `<select id="${field.name}" name="${field.name}" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-primary focus:border-primary" ${field.required ? 'required' : ''}>`;
            field.options.forEach(option => {
              const selected = (String(currentValue).toLowerCase() === String(option).toLowerCase()) ? 'selected' : '';
              formHtml += `<option value="${option}" ${selected}>${option}</option>`;
            });
            formHtml += `</select>`;
            break;
          case 'checkbox':
            const checked = currentValue ? 'checked' : '';
            formHtml += `<input type="checkbox" id="${field.name}" name="${field.name}" class="mt-1 h-4 w-4 text-primary focus:ring-primary border-gray-300" ${checked}>`;
            break;
        }
        formHtml += `</div>`;
      });
      registryEntryForm.innerHTML = formHtml;
    }

    // --- 9. 收集表单数据 ---
    function collectFormData() {
      const formData = {};
      const registryConfig = allRegistryMetaData[currentRegistryType];
      const fields = registryConfig.fields;
      
      fields.forEach(field => {
        const inputElement = registryEntryForm.querySelector(`[name="${field.name}"]`);
        if (inputElement) {
          if (field.type === 'checkbox') {
            formData[field.name] = inputElement.checked;
          } else if (field.type === 'number') {
            formData[field.name] = parseFloat(inputElement.value) || 0;
          } else if (field.type === 'textarea' && field.notes && field.notes.includes('JSON')) {
            try {
              // 尝试解析 JSON 字符串
              formData[field.name] = JSON.parse(inputElement.value);
            } catch (e) {
              alert(`字段 "${field.label}" 的 JSON 格式无效，请检查！错误: ${e.message}`);
              throw new Error(`Invalid JSON format for ${field.name}`); // 抛出错误以阻止保存
            }
          } else if (field.type === 'textarea') {
            // 逗号分隔的文本框转为数组
            formData[field.name] = inputElement.value.split(',').map(s => s.trim()).filter(Boolean);
          } else {
            formData[field.name] = inputElement.value;
          }
        } else if (field.editable === false && currentEditEntryId) {
          // 对于不可编辑的字段，从原始数据中保留其值
          // 更好的做法是，在 handleEditEntry 成功后，将完整数据存储在一个全局变量中，
          // 然后在这里从那个全局变量中获取。这里简化处理，假设后端会处理。
          // 或者从隐藏的 input type="hidden" 中获取
          const hiddenInput = registryEntryForm.querySelector(`input[type="hidden"][name="${field.name}"]`);
          if (hiddenInput) {
            // 对于 JSON 隐藏字段，它存储的是 stringified JSON
            if (field.type === 'textarea' && field.notes && field.notes.includes('JSON')) {
              try {
                formData[field.name] = JSON.parse(hiddenInput.value);
              } catch (e) {
                console.error(`Error parsing hidden JSON field ${field.name}:`, e);
                formData[field.name] = null; // 或者保留原始字符串
              }
            } else {
              formData[field.name] = hiddenInput.value;
            }
          }
        }
      });

      if (currentEditEntryId) {
        formData[registryConfig.idField] = currentEditEntryId;
      }
      
      return formData;
    }

    // ... (其他 JavaScript 逻辑) ...
    ```

**3.4. 最终验证 (手动测试)**

*   **操作：**
    1.  部署最新的 Apps Script Web 应用。
    2.  打开您的 Deepdive Engine Web 界面。
    3.  导航到 `System` -> `数据源管理` -> `外部数据源` Tab。
    4.  **验证列表：** 检查是否正确显示了您在 Firestore 中添加的 `ARXIV_API`、`NEWSAPI_ORG`、`OPENAI_API` 等数据源。
    5.  **验证“编辑”：**
        *   点击 `ARXIV_API` 的“编辑”按钮。
        *   检查模态框中所有字段是否正确填充。特别是 `endpoint_paths` 和 `request_headers` 是否以格式化的 JSON 显示在 `textarea` 中。
        *   尝试修改 `display_name` 或 `is_active`，然后保存。
        *   验证列表是否更新，并在 Firestore 中检查对应文档是否修改成功。
    6.  **验证“新增”：**
        *   点击“添加新条目”按钮。
        *   尝试添加一个虚拟的新的新闻源，例如 `{"source_id": "MOCK_NEWS_API", "display_name": "模拟新闻源", "source_type": "news_source", "base_url": "https://mockapi.com", "endpoint_paths": {"v1": "/news"}, "request_method": "GET", "payload_type": "none", "response_type": "json", "auth_method": "none", "is_active": true, "priority": 50, "notes": "用于测试的新闻源"}`。
        *   确保所有必填字段都能正确填写并保存。
        *   验证新条目是否出现在列表中，并在 Firestore 中检查是否添加成功。
    7.  **验证“删除”：**
        *   尝试删除您刚刚添加的“MOCK\_NEWS\_API”条目。
        *   验证条目是否从列表中移除，并在 Firestore 中检查是否删除成功。
    8.  **重新运行工作流：** 再次运行 `test_Workflows_All()`，确保所有工作流在新的 `DataConnector` 架构下依然能够正常工作，并且能够从 Firestore 读取最新的 `external_data_sources` 配置。

---

通过以上严谨的步骤，您将成功实现外部数据源的自适应管理，并确保现有功能在重构后依然稳定运行。这是一个非常重要的里程碑，它为您的 Deepdive 系统带来了前所未有的灵活性和可扩展性！

好的，Jason。我们已经成功完成了这次意义重大的架构升级。现在，让我们系统地回顾和总结这个**《自适应外部数据源架构方案》**，将其沉淀为一份清晰、完整的技术文档。

---

### **《自适应外部数据源架构方案》总结报告**

#### **1. 方案背景与目标**

在技术情报收集中，外部数据源具有多样性、异构性和不稳定性等特点。传统的为每个API硬编码数据采集逻辑的开发模式，导致系统耦合度高、扩展困难、维护成本巨大。

本方案的核心目标是**将数据源的“连接与解析协议”从业务代码中剥离，实现数据化和可配置化**。通过此方案，系统能够动态适应不同的API，达到“**通过后台配置即可轻松扩展新数据源，而无需修改核心代码**”的终极目标，从而极大地提升系统的灵活性、可扩展性和可维护性。

#### **2. 核心设计理念**

本方案的成功，得益于以下几个核心设计理念的贯彻：

*   **配置即数据 (Configuration as Data):** 将API的URL、认证方式、请求方法、参数名、响应结构等所有“协议”信息，作为结构化数据存储在Firestore的`external_data_sources`集合中。
*   **协议适配 (Protocol Adaptation):** 构建了一个通用的`DataConnector`服务，它如同一个“万能插座”，能够读取任何数据源的“协议”配置，并动态构建出完全匹配的HTTP请求。
*   **映射即服务 (Mapping as a Service):** 创建了一个通用的`DataMapper`工具，它能够根据配置中的`response_mapping_rules`，将任何格式的API响应数据，自动转换为系统内部统一的标准数据模型。
*   **高度解耦 (High Decoupling):** 业务逻辑层（如`WorkflowsService`）被彻底解放，它不再关心数据“从哪里来、如何来”，只需声明“需要什么类型的数据”，然后处理由`DataMapper`提供的、格式统一的标准数据即可。

#### **3. 系统架构与数据流**

我们成功构建了一个清晰、分层的数据处理流水线：

```mermaid
graph TD
    A[业务工作流<br>(e.g., WF4: TechNews)] -->|1. 请求'news_source'类型数据| B(DataConnector);
    B -->|2. 查询配置| C{Firestore: external_data_sources};
    C -->|3. 返回所有新闻源配置<br>(NewsAPI, HackerNews)| B;
    B -->|4. 遍历配置, 动态构建请求<br>- NewsAPI: GET ...&q=...&pageSize=...<br>- HackerNews: GET ...&query=...&hitsPerPage=...| D[外部API服务];
    D -->|5. 返回异构响应<br>(不同JSON结构)| B;
    B -->|6. 返回原始响应数据| A;
    A -->|7. 调用DataMapper进行适配| E(DataMapper);
    E -->|8. 读取配置中的映射规则| C;
    C -->|9. 返回映射规则| E;
    E -->|10. 返回统一格式的数据| A;
    A -->|11. 进行AI处理和存储| F[Firestore: raw_tech_news];

    style A fill:#cde,stroke:#333,stroke-width:2px
    style B fill:#f9f,stroke:#333,stroke-width:2px
    style E fill:#f9f,stroke:#333,stroke-width:2px
    style C fill:#ddf,stroke:#333,stroke-width:2px
    style F fill:#ddf,stroke:#333,stroke-width:2px
    style D fill:#bfb,stroke:#333,stroke-width:2px
```

**数据流解读:**
1.  **业务层发起请求**: 工作流向`DataConnector`请求所有类型为`news_source`的数据。
2.  **连接器获取协议**: `DataConnector`从Firestore加载所有匹配的“连接协议”（NewsAPI和HackerNews的配置）。
3.  **动态API调用**: `DataConnector`遍历每个协议，根据其独特的参数名（`q` vs `query`, `pageSize` vs `hitsPerPage`）构建并发送请求。
4.  **映射器进行适配**: 工作流接收到格式各异的原始响应后，将其和对应的映射规则一同交给`DataMapper`。
5.  **生成标准数据**: `DataMapper`将不同结构的数据（例如，一个来自`articles`数组，一个来自`hits`数组）全部转换为系统内部的统一标准格式。
6.  **通用业务处理**: 工作流对这些格式统一的数据进行后续的AI分析和存储，无需再编写任何`if/else`来区分数据来源。

#### **4. 关键组件与实现**

*   **`external_data_sources` 集合 (in Firestore):**
    *   **职责**: 系统的“协议库”，是整个架构的真理之源。
    *   **核心字段**: `source_id`, `source_type`, `base_url`, `endpoint_paths`, `auth_method`, `api_key_name`, `pagination_param_names`, `dynamic_param_names`, `response_mapping_rules`。这些字段共同完整地描述了一个外部API。

*   **`DataConnector` 服务 (in `svc.DataConnector.gs`):**
    *   **职责**: 系统的“通用连接器”和“协议执行引擎”。
    *   **核心方法**: `fetchExternalData`，它实现了对不同HTTP方法、认证方式、参数名和请求体的完全自适应。

*   **`DataMapper` 工具 (in `A_utils.gs`):**
    *   **职责**: 系统的“通用数据转换器”。
    *   **核心方法**: `map` 和 `getRawItems`，它们将数据映射的规则（`response_mapping_rules`）应用到实际的API响应上，实现了业务适配的自动化。

*   **管理后台 (in `System` Page):**
    *   **职责**: 提供了用户友好的图形化界面，让非开发人员也能安全、便捷地对所有“连接协议”进行增、删、改、查，是架构落地和日常维护的关键。

#### **5. 成果与价值**

通过本次架构升级，我们取得了以下关键成果：

*   **极致的灵活性**: 接入一个新的新闻API（或任何其他类型的源），现在的工作从**“数天的编码和测试”**转变为**“几分钟的后台配置”**。
*   **极高的可维护性**: 当某个API变更其字段名或参数名时，我们只需在后台修改对应的配置，而无需触及任何业务代码，大大降低了维护成本和风险。
*   **清晰的职责分离**: `DataConnector` 专心负责“连接”，`DataMapper` 专心负责“转换”，`WorkflowsService` 专心负责“业务”，代码结构更加清晰、健壮和易于理解。
*   **赋能业务人员**: 使得技术分析师或运营人员也能通过后台配置，参与到扩充系统数据源的工作中来，加速了情报的获取和迭代。

**总而言之，我们成功地将系统的核心能力从“编码实现”转向了“配置驱动”，为Deepdive Engine未来的高速发展和迭代，奠定了坚如磐SHÍ的架构基础。**